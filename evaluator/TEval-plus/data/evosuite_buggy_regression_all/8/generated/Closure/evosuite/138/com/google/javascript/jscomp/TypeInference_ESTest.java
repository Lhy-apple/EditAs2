/*
 * This file was automatically generated by EvoSuite
 * Wed Jul 12 02:28:51 GMT 2023
 */

package com.google.javascript.jscomp;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import com.google.common.collect.Multimap;
import com.google.javascript.jscomp.ClosureCodingConvention;
import com.google.javascript.jscomp.Compiler;
import com.google.javascript.jscomp.ControlFlowGraph;
import com.google.javascript.jscomp.FlowScope;
import com.google.javascript.jscomp.GoogleCodingConvention;
import com.google.javascript.jscomp.LinkedFlowScope;
import com.google.javascript.jscomp.PrintStreamErrorManager;
import com.google.javascript.jscomp.ReverseAbstractInterpreter;
import com.google.javascript.jscomp.Scope;
import com.google.javascript.jscomp.SemanticReverseAbstractInterpreter;
import com.google.javascript.jscomp.TightenTypes;
import com.google.javascript.jscomp.TypeInference;
import com.google.javascript.jscomp.TypedScopeCreator;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.jstype.BooleanLiteralSet;
import com.google.javascript.rhino.jstype.JSType;
import com.google.javascript.rhino.jstype.JSTypeRegistry;
import com.google.javascript.rhino.jstype.NamedType;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.List;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class TypeInference_ESTest extends TypeInference_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void test00()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString("//.oTOfUN9&\"*~!");
      Node node1 = new Node(101, node0, node0, node0, node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = new Scope(node0, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // AND : com.google.javascript.rhino.jstype.StringType@0000000042 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test01()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("//.oTOfUN9&\"*~!");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      Scope scope0 = new Scope(node0, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0);
      typeInference0.analyze(39);
  }

  @Test(timeout = 4000)
  public void test02()  throws Throwable  {
      Compiler compiler0 = new Compiler((PrintStream) null);
      Node node0 = compiler0.parseSyntheticCode("W]0}", "D0LV&W_S^k|@|;");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      Scope scope0 = new Scope(node0, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0);
      Multimap<Scope, Scope.Var> multimap0 = typeInference0.getAssignedOuterLocalVars();
      assertNotNull(multimap0);
  }

  @Test(timeout = 4000)
  public void test03()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString(33, "");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      Scope scope0 = new Scope(node0, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test04()  throws Throwable  {
      Node node0 = Node.newString("//.oTOfUN9&\"*~!");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0);
  }

  @Test(timeout = 4000)
  public void test05()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString("//.oTOfUN9&\"*~!");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      Scope scope0 = new Scope(node0, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0);
      FlowScope flowScope0 = typeInference0.createInitialEstimateLattice();
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, flowScope0);
      assertTrue(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void test06()  throws Throwable  {
      Node node0 = Node.newString("//.oTOfUN9&\"*~!");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      Node node1 = new Node(4, node0);
      Compiler compiler0 = new Compiler();
      Scope scope0 = new Scope(node1, compiler0);
      GoogleCodingConvention googleCodingConvention0 = (GoogleCodingConvention)compiler0.defaultCodingConvention;
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // RETURN does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test07()  throws Throwable  {
      Node node0 = Node.newString("//.oTOfUN9&\"*~!");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      node0.setType(5);
      Compiler compiler0 = new Compiler();
      Scope scope0 = new Scope(node0, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
      assertTrue(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void test08()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString("//.oTOfUN9&\"*~!");
      Node node1 = Node.newString(11, "//.oTOfUN9&\"*~!");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      Scope scope0 = new Scope(node1, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // BITAND //.oTOfUN9&\"*~! : com.google.javascript.rhino.jstype.NumberType@0000000041 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test09()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString("//.oTOfUN9&\"*~!");
      Node node1 = Node.newString(18, "//.oTOfUN9&\"*~!");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      Scope scope0 = new Scope(node1, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // LSH //.oTOfUN9&\"*~! : com.google.javascript.rhino.jstype.NumberType@0000000041 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test10()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString("//.oTOfUN9&\"*~!");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      Scope scope0 = new Scope(node0, compiler0);
      Node node1 = new Node(19);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
      assertNotSame(flowScope1, flowScope0);
  }

  @Test(timeout = 4000)
  public void test11()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString("//.oTOfUN9&\"*~!");
      Node node1 = Node.newString(23, "//.oTOfUN9&\"*~!");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      Scope scope0 = new Scope(node0, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // MUL //.oTOfUN9&\"*~! : com.google.javascript.rhino.jstype.NumberType@0000000041 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test12()  throws Throwable  {
      PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager((PrintStream) null);
      Compiler compiler0 = new Compiler(printStreamErrorManager0);
      Node node0 = new Node(24);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      Scope scope0 = new Scope(node0, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, flowScope0);
      assertTrue(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void test13()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString("//.oTOfUN9&\"*~!");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      Scope scope0 = new Scope(node0, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(25, 112, 48);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test14()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString("");
      Node node1 = Node.newString(27, "g");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1);
      Scope scope0 = new Scope(node0, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node1, flowScope0);
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void test15()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString("//.oTOfUN9&\"*~!");
      Node node1 = Node.newString(36, "//.oTOfUN9&\"*~!");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      Scope scope0 = new Scope(node0, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // SETELEM //.oTOfUN9&\"*~! does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test16()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString("//.oTOfUN9&\"*!");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      Scope scope0 = new Scope(node0, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
      JSType[] jSTypeArray0 = new JSType[1];
      NamedType namedType0 = new NamedType(jSTypeRegistry0, "TightenTypes pass appears to be stuck in an infinite loop.", "'3;GR", 35, (-656));
      JSType jSType0 = namedType0.getReferencedType();
      jSTypeArray0[0] = jSType0;
      Node node1 = jSTypeRegistry0.createParametersWithVarArgs(jSTypeArray0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // LP : com.google.javascript.rhino.jstype.UnknownType@0000000043 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test17()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      Scope scope0 = new Scope(node0, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      Node node1 = Node.newNumber((-2833.04572868), 48, 2);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // NUMBER -2833.04572868 48 : com.google.javascript.rhino.jstype.NumberType@0000000041 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test18()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString("//.oTOfUN9&\"*~!");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      node0.setType(41);
      Scope scope0 = new Scope(node0, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, flowScope0);
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void test19()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString("//.oTOfUN&\"~!");
      Node node1 = Node.newString(43, "//.oTOfUN&\"~!", 43, 25);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = new Scope(node1, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // FALSE //.oTOfUN&\"~! 43 : com.google.javascript.rhino.jstype.BooleanType@0000000039 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test20()  throws Throwable  {
      Node node0 = Node.newString("//.oTOfUN9&\"*~!");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      node0.setType(45);
      Compiler compiler0 = new Compiler();
      Scope scope0 = new Scope(node0, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
      assertTrue(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void test21()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString("//.oTOfUN9&\"*~!");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      Scope scope0 = new Scope(node0, compiler0);
      Node node1 = new Node(49, node0, node0, node0, node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // THROW does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test22()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString("//.oTOfUN9&\"*~c!");
      Node node1 = Node.newString(84, "//.oTOfUN9&\"*~!");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      Scope scope0 = new Scope(node1, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // RP //.oTOfUN9&\"*~! does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test23()  throws Throwable  {
      PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager((PrintStream) null);
      Compiler compiler0 = new Compiler(printStreamErrorManager0);
      Node node0 = Node.newString("");
      Node node1 = Node.newString(85, "//.oTOfUN9&\"*~!");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1);
      Scope scope0 = new Scope(node0, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test24()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString("//.oTOfUN9&\"*~!");
      Node node1 = Node.newString(95, "//.oTOfUN9&\"*~!");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      Scope scope0 = new Scope(node0, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // ASSIGN_MUL //.oTOfUN9&\"*~! : com.google.javascript.rhino.jstype.NumberType@0000000041 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test25()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString("//.oTOfUN9&\"*~!");
      Node node1 = Node.newString(96, "mm8IQ 6+'d(CG", 45, 1664);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = new Scope(node1, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // ASSIGN_DIV mm8IQ 6+'d(CG 45 : com.google.javascript.rhino.jstype.NumberType@0000000041 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test26()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("//.oTOfUN9&\"*~!");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      node0.setType(98);
      Scope scope0 = new Scope(node0, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test27()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("//.oTOfUN9&\"*~!");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      Scope scope0 = new Scope(node0, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0);
      Node node1 = Node.newString(106, "Ae!\"F");
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // EXPORT Ae!\"F does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test28()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString(107, "//.oTOfUN9&\"*~!");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      Scope scope0 = new Scope(node0, compiler0);
      GoogleCodingConvention googleCodingConvention0 = (GoogleCodingConvention)compiler0.defaultCodingConvention;
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, arrayList0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node0, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test29()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString("//.oTOfUN9&\"*~!");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      Scope scope0 = new Scope(node0, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      Node node1 = new Node(109, node0, node0, node0, node0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // ELSE does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test30()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString("//.oTOfUN9&\"*~!");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      Scope scope0 = new Scope(node0, compiler0);
      Node node1 = compiler0.parseSyntheticCode("//.oTOfUN9&\"*~!", "//.oTOfUN9&\"*~!");
      Node node2 = new Node(111, node1, node1, node0, node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      FlowScope flowScope1 = typeInference0.flowThrough(node2, flowScope0);
      assertNotSame(flowScope1, flowScope0);
  }

  @Test(timeout = 4000)
  public void test31()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("//.oTOfUN9&\"*~!");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      Scope scope0 = new Scope(node0, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0);
      node0.setType(113);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void test32()  throws Throwable  {
      Node node0 = Node.newString("//.oTOfUN9&\"*~!");
      Node node1 = Node.newString(116, "//.oTOfUN9&\"*~!");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      Compiler compiler0 = new Compiler();
      Scope scope0 = new Scope(node0, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // BREAK //.oTOfUN9&\"*~! does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test33()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString("//.oTOfUN9&\"*~!");
      Node node1 = Node.newString(117, "//.oTOfUN9&\"*~!");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      Scope scope0 = new Scope(node1, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // CONTINUE //.oTOfUN9&\"*~! does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test34()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString("");
      Node node1 = Node.newString(123, "");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = new Scope(node1, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // RESERVED  does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test35()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("5/r/ I?/Cn!");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      Scope scope0 = new Scope(node0, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      FlowScope flowScope1 = typeInference0.flowThrough(node0, flowScope0);
      assertNotSame(flowScope1, flowScope0);
  }

  @Test(timeout = 4000)
  public void test36()  throws Throwable  {
      Compiler compiler0 = new Compiler((PrintStream) null);
      Node node0 = compiler0.parseSyntheticCode("W]0}", "D0LV&W_S^k|@|;");
      Node node1 = new Node(127, node0, node0, node0, node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1);
      Scope scope0 = new Scope(node1, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test37()  throws Throwable  {
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.TRUE;
      BooleanLiteralSet booleanLiteralSet1 = TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet0, false);
      assertSame(booleanLiteralSet1, booleanLiteralSet0);
  }
}
