/*
 * This file was automatically generated by EvoSuite
 * Tue Sep 26 14:24:43 GMT 2023
 */

package com.google.javascript.jscomp;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import com.google.javascript.jscomp.CheckLevel;
import com.google.javascript.jscomp.CleanupPasses;
import com.google.javascript.jscomp.ClosureCodingConvention;
import com.google.javascript.jscomp.Compiler;
import com.google.javascript.jscomp.CompilerOptions;
import com.google.javascript.jscomp.JqueryCodingConvention;
import com.google.javascript.jscomp.MemoizedScopeCreator;
import com.google.javascript.jscomp.NodeTraversal;
import com.google.javascript.jscomp.PrintStreamErrorManager;
import com.google.javascript.jscomp.Scope;
import com.google.javascript.jscomp.ScopeCreator;
import com.google.javascript.jscomp.SyntacticScopeCreator;
import com.google.javascript.jscomp.TypeCheck;
import com.google.javascript.jscomp.TypedScopeCreator;
import com.google.javascript.jscomp.UnreachableCodeElimination;
import com.google.javascript.jscomp.type.ClosureReverseAbstractInterpreter;
import com.google.javascript.jscomp.type.ReverseAbstractInterpreter;
import com.google.javascript.jscomp.type.SemanticReverseAbstractInterpreter;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.SimpleErrorReporter;
import com.google.javascript.rhino.jstype.JSType;
import com.google.javascript.rhino.jstype.JSTypeRegistry;
import java.util.ArrayList;
import java.util.List;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.mock.java.io.MockPrintStream;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class TypeCheck_ESTest extends TypeCheck_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void test00()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("l+dI-_");
      PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager(mockPrintStream0);
      Compiler compiler0 = new Compiler(printStreamErrorManager0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention(closureCodingConvention0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
      Node node0 = compiler0.parseTestCode("l+dI-_");
      Node node1 = new Node(86, node0, node0, node0, node0, 36, 54);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      typeCheck0.processForTesting(node0, node0);
  }

  @Test(timeout = 4000)
  public void test01()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("l+dI-_");
      PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager(mockPrintStream0);
      Compiler compiler0 = new Compiler(printStreamErrorManager0);
      UnreachableCodeElimination unreachableCodeElimination0 = new UnreachableCodeElimination(compiler0, false);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, unreachableCodeElimination0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      compiler0.initCompilerOptionsIfTesting();
      CheckLevel checkLevel0 = CheckLevel.OFF;
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0, checkLevel0, checkLevel0);
      Node node0 = compiler0.parseTestCode("l+dI-_");
      Node node1 = new Node(47, node0, node0, node0, node0, 42, 29);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      double double0 = typeCheck0.getTypedPercent();
      assertEquals(100.0, double0, 0.01);
  }

  @Test(timeout = 4000)
  public void test02()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("l+dI-_");
      PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager(mockPrintStream0);
      Compiler compiler0 = new Compiler(printStreamErrorManager0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      CheckLevel checkLevel0 = CheckLevel.OFF;
      Node node0 = compiler0.parseTestCode("l+dI-_");
      SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
      Scope scope0 = syntacticScopeCreator0.createScope(node0, (Scope) null);
      MemoizedScopeCreator memoizedScopeCreator0 = new MemoizedScopeCreator(syntacticScopeCreator0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0, scope0, memoizedScopeCreator0, checkLevel0, checkLevel0);
      // Undeclared exception!
      try { 
        typeCheck0.process((Node) null, node0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.common.base.Preconditions", e);
      }
  }

  @Test(timeout = 4000)
  public void test03()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("l+dI-_");
      PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager(mockPrintStream0);
      Compiler compiler0 = new Compiler(printStreamErrorManager0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      CheckLevel checkLevel0 = CheckLevel.OFF;
      Node node0 = compiler0.parseTestCode("l+dI-_");
      Node node1 = new Node(47, node0, node0, node0, node0, 42, 29);
      SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
      Scope scope0 = syntacticScopeCreator0.createScope(node1, (Scope) null);
      MemoizedScopeCreator memoizedScopeCreator0 = new MemoizedScopeCreator(syntacticScopeCreator0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0, scope0, memoizedScopeCreator0, checkLevel0, checkLevel0);
      typeCheck0.process((Node) null, node0);
      assertFalse(compiler0.hasErrors());
      assertEquals(0, printStreamErrorManager0.getErrorCount());
  }

  @Test(timeout = 4000)
  public void test04()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("l+dI-_");
      PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager(mockPrintStream0);
      Compiler compiler0 = new Compiler(printStreamErrorManager0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      CheckLevel checkLevel0 = CheckLevel.OFF;
      Node node0 = compiler0.parseTestCode("l+dI-_");
      Node node1 = new Node(55, node0, node0, node0, node0, 8, 47);
      SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
      MemoizedScopeCreator memoizedScopeCreator0 = new MemoizedScopeCreator(syntacticScopeCreator0);
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Scope scope0 = typedScopeCreator0.createScope(node1, (Scope) null);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0, scope0, memoizedScopeCreator0, checkLevel0, compilerOptions0.checkMissingGetCssNameLevel);
      // Undeclared exception!
      try { 
        typeCheck0.process(node1, node0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.common.base.Preconditions", e);
      }
  }

  @Test(timeout = 4000)
  public void test05()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("l+dI-_");
      PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager(mockPrintStream0);
      Compiler compiler0 = new Compiler(printStreamErrorManager0);
      UnreachableCodeElimination unreachableCodeElimination0 = new UnreachableCodeElimination(compiler0, true);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, unreachableCodeElimination0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      compiler0.initCompilerOptionsIfTesting();
      CheckLevel checkLevel0 = CheckLevel.WARNING;
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0, checkLevel0, checkLevel0);
      Node node0 = compiler0.parseTestCode("l+dI-_");
      // Undeclared exception!
      try { 
        typeCheck0.processForTesting(node0, node0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.common.base.Preconditions", e);
      }
  }

  @Test(timeout = 4000)
  public void test06()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("l+dI-_");
      PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager(mockPrintStream0);
      Compiler compiler0 = new Compiler(printStreamErrorManager0);
      UnreachableCodeElimination unreachableCodeElimination0 = new UnreachableCodeElimination(compiler0, true);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention(closureCodingConvention0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
      Node node0 = compiler0.parseTestCode("l+dI-_");
      Node node1 = new Node(86, node0, node0, node0, node0, 36, 54);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, unreachableCodeElimination0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(8, Node.FLAG_NO_THROWS);
  }

  @Test(timeout = 4000)
  public void test07()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("l+dI-_");
      PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager(mockPrintStream0);
      Compiler compiler0 = new Compiler(printStreamErrorManager0);
      UnreachableCodeElimination unreachableCodeElimination0 = new UnreachableCodeElimination(compiler0, true);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, unreachableCodeElimination0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      compiler0.initCompilerOptionsIfTesting();
      CheckLevel checkLevel0 = CheckLevel.WARNING;
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0, checkLevel0, checkLevel0);
      Node node0 = compiler0.parseTestCode("l+dI-_");
      Node node1 = new Node(125, node0, node0, node0, node0, 43, 32);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertFalse(node1.isGetProp());
  }

  @Test(timeout = 4000)
  public void test08()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("l+dI-_");
      PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager(mockPrintStream0);
      Compiler compiler0 = new Compiler(printStreamErrorManager0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention(closureCodingConvention0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
      compiler0.initCompilerOptionsIfTesting();
      CheckLevel checkLevel0 = CheckLevel.OFF;
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0, checkLevel0, checkLevel0);
      Node node0 = compiler0.parseTestCode("c<,Vn_}");
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      node0.addSuppression("l+dI-_");
      typeCheck0.visit(nodeTraversal0, node0, node0);
      assertFalse(node0.isAssignAdd());
  }

  @Test(timeout = 4000)
  public void test09()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("JSC_INTERFACE_FUNCTION_NOT_EMPTY");
      PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager(mockPrintStream0);
      Compiler compiler0 = new Compiler(printStreamErrorManager0);
      UnreachableCodeElimination unreachableCodeElimination0 = new UnreachableCodeElimination(compiler0, false);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, unreachableCodeElimination0);
      compiler0.initCompilerOptionsIfTesting();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
      TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
      Node node0 = new Node(149, 1, 54);
      typeCheck0.visit(nodeTraversal0, node0, node0);
      assertTrue(compiler0.hasErrors());
      assertEquals(1, printStreamErrorManager0.getErrorCount());
  }

  @Test(timeout = 4000)
  public void test10()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("l+dI-_");
      PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager(mockPrintStream0);
      Compiler compiler0 = new Compiler(printStreamErrorManager0);
      UnreachableCodeElimination unreachableCodeElimination0 = new UnreachableCodeElimination(compiler0, false);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, unreachableCodeElimination0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      compiler0.initCompilerOptionsIfTesting();
      CheckLevel checkLevel0 = CheckLevel.OFF;
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0, checkLevel0, checkLevel0);
      Node node0 = compiler0.parseTestCode("JSC_UNKNOWN_OVERRIDE");
      Node node1 = new Node(4, node0, node0, node0, node0, 2869, 43);
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node1, node0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeCheck", e);
      }
  }

  @Test(timeout = 4000)
  public void test11()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("l+dI-_");
      PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager(mockPrintStream0);
      Compiler compiler0 = new Compiler(printStreamErrorManager0);
      UnreachableCodeElimination unreachableCodeElimination0 = new UnreachableCodeElimination(compiler0, false);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention(closureCodingConvention0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
      compiler0.initCompilerOptionsIfTesting();
      CheckLevel checkLevel0 = CheckLevel.OFF;
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0, checkLevel0, checkLevel0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, unreachableCodeElimination0);
      Node node0 = new Node(7, 7, 2810);
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node0, node0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 7
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test12()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("l+dI-_");
      PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager(mockPrintStream0);
      Compiler compiler0 = new Compiler(printStreamErrorManager0);
      UnreachableCodeElimination unreachableCodeElimination0 = new UnreachableCodeElimination(compiler0, true);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, unreachableCodeElimination0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      Node node0 = compiler0.parseTestCode("`RCq$KhQN3e^K");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0, compilerOptions0.checkGlobalNamesLevel, compilerOptions0.checkRequires);
      Node node1 = new Node(8, 51, 83);
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node1, node0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 8
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test13()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("l+dI-_");
      PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager(mockPrintStream0);
      Compiler compiler0 = new Compiler(printStreamErrorManager0);
      UnreachableCodeElimination unreachableCodeElimination0 = new UnreachableCodeElimination(compiler0, true);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, unreachableCodeElimination0);
      Node node0 = compiler0.parseTestCode("l+dI-_");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
      TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
      Node node1 = new Node(12, node0);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertFalse(node1.isCatch());
  }

  @Test(timeout = 4000)
  public void test14()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("zl+dI-_");
      PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager(mockPrintStream0);
      Compiler compiler0 = new Compiler(printStreamErrorManager0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      compiler0.initCompilerOptionsIfTesting();
      CheckLevel checkLevel0 = CheckLevel.ERROR;
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0, checkLevel0, checkLevel0);
      Node node0 = compiler0.parseTestCode("zl+dI-_");
      Node node1 = new Node(15, node0, node0, node0, node0, 143, 47);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertFalse(compiler0.hasErrors());
      assertEquals(0, printStreamErrorManager0.getErrorCount());
  }

  @Test(timeout = 4000)
  public void test15()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("l+dI-_");
      PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager(mockPrintStream0);
      Compiler compiler0 = new Compiler(printStreamErrorManager0);
      UnreachableCodeElimination unreachableCodeElimination0 = new UnreachableCodeElimination(compiler0, true);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, unreachableCodeElimination0);
      compiler0.initCompilerOptionsIfTesting();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
      TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
      Node node0 = new Node(16, (-1), 30);
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node0, node0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeCheck", e);
      }
  }

  @Test(timeout = 4000)
  public void test16()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("l+dI-_");
      PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager(mockPrintStream0);
      Compiler compiler0 = new Compiler(printStreamErrorManager0);
      UnreachableCodeElimination unreachableCodeElimination0 = new UnreachableCodeElimination(compiler0, false);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, unreachableCodeElimination0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      compiler0.initCompilerOptionsIfTesting();
      CheckLevel checkLevel0 = CheckLevel.OFF;
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0, checkLevel0, checkLevel0);
      Node node0 = compiler0.parseTestCode("l+dI-_");
      Node node1 = new Node(25, node0, node0, node0, node0, 260, 51);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertFalse(compiler0.hasErrors());
      assertEquals(0, printStreamErrorManager0.getErrorCount());
  }

  @Test(timeout = 4000)
  public void test17()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("l+dI-_");
      PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager(mockPrintStream0);
      Compiler compiler0 = new Compiler(printStreamErrorManager0);
      UnreachableCodeElimination unreachableCodeElimination0 = new UnreachableCodeElimination(compiler0, false);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, unreachableCodeElimination0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      compiler0.initCompilerOptionsIfTesting();
      CheckLevel checkLevel0 = CheckLevel.OFF;
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0, checkLevel0, checkLevel0);
      Node node0 = compiler0.parseTestCode("");
      Node node1 = new Node(29, node0, node0, node0, node0, 4148, 109);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertFalse(node1.isRegExp());
  }

  @Test(timeout = 4000)
  public void test18()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("");
      Node node1 = new Node(30, node0, node0, node0, node0, 128, 12);
      CompilerOptions compilerOptions0 = compiler0.getOptions();
      CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
      TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test19()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("l+dI-_");
      PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager(mockPrintStream0);
      Compiler compiler0 = new Compiler(printStreamErrorManager0);
      UnreachableCodeElimination unreachableCodeElimination0 = new UnreachableCodeElimination(compiler0, false);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, unreachableCodeElimination0);
      Node node0 = compiler0.parseTestCode("0iV^_o$)\"=dj4B[u");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
      TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
      Node node1 = new Node(31, (-373), 38);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertFalse(node1.isOr());
  }

  @Test(timeout = 4000)
  public void test20()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("l+dI-_");
      PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager(mockPrintStream0);
      Compiler compiler0 = new Compiler(printStreamErrorManager0);
      UnreachableCodeElimination unreachableCodeElimination0 = new UnreachableCodeElimination(compiler0, true);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, unreachableCodeElimination0);
      Node node0 = compiler0.parseTestCode("JSC_UNKNOWN_OVERRIDE");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
      TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
      Node node1 = new Node(36, node0);
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node1, node0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 36
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test21()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("l+dI-_");
      PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager(mockPrintStream0);
      Compiler compiler0 = new Compiler(printStreamErrorManager0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention(closureCodingConvention0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
      compiler0.initCompilerOptionsIfTesting();
      CheckLevel checkLevel0 = CheckLevel.OFF;
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0, checkLevel0, checkLevel0);
      Node node0 = compiler0.parseTestCode("");
      Node node1 = new Node(37, node0, node0, node0, node0, 53, 53);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertEquals(0, compiler0.getWarningCount());
      assertEquals(0, printStreamErrorManager0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test22()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("l+dI-_");
      PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager(mockPrintStream0);
      Compiler compiler0 = new Compiler(printStreamErrorManager0);
      UnreachableCodeElimination unreachableCodeElimination0 = new UnreachableCodeElimination(compiler0, true);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, unreachableCodeElimination0);
      Node node0 = compiler0.parseTestCode("`RCq$KhQN3e^K");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
      TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
      Node node1 = Node.newNumber((double) 0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(52, Node.LENGTH);
  }

  @Test(timeout = 4000)
  public void test23()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("l+dI-_");
      PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager(mockPrintStream0);
      Compiler compiler0 = new Compiler(printStreamErrorManager0);
      UnreachableCodeElimination unreachableCodeElimination0 = new UnreachableCodeElimination(compiler0, false);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, unreachableCodeElimination0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      compiler0.initCompilerOptionsIfTesting();
      CheckLevel checkLevel0 = CheckLevel.OFF;
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0, checkLevel0, checkLevel0);
      Node node0 = Node.newString("JSC_UNKNOWN_OVERRIDE");
      typeCheck0.visit(nodeTraversal0, node0, node0);
      assertEquals(2, Node.FLAG_THIS_UNMODIFIED);
  }

  @Test(timeout = 4000)
  public void test24()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("l+dI-_");
      PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager(mockPrintStream0);
      Compiler compiler0 = new Compiler(printStreamErrorManager0);
      UnreachableCodeElimination unreachableCodeElimination0 = new UnreachableCodeElimination(compiler0, true);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, unreachableCodeElimination0);
      Node node0 = compiler0.parseTestCode("JSC_UNKNHWN_ODERRIDE");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
      TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
      Node node1 = new Node(42, 36, 109);
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node1, node0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeCheck", e);
      }
  }

  @Test(timeout = 4000)
  public void test25()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("l+dI-_");
      PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager(mockPrintStream0);
      Compiler compiler0 = new Compiler(printStreamErrorManager0);
      UnreachableCodeElimination unreachableCodeElimination0 = new UnreachableCodeElimination(compiler0, false);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, unreachableCodeElimination0);
      Node node0 = compiler0.parseTestCode("JSC_UNKNOWN_OVERRIDE");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
      TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
      Node node1 = new Node(43, 140, 19);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertFalse(node1.isWhile());
  }

  @Test(timeout = 4000)
  public void test26()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("l+dI-_");
      PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager(mockPrintStream0);
      Compiler compiler0 = new Compiler(printStreamErrorManager0);
      UnreachableCodeElimination unreachableCodeElimination0 = new UnreachableCodeElimination(compiler0, false);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      compiler0.initCompilerOptionsIfTesting();
      CheckLevel checkLevel0 = CheckLevel.OFF;
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0, checkLevel0, checkLevel0);
      Node node0 = compiler0.parseTestCode("l+dI-_");
      Node node1 = new Node(46, node0, node0, node0, node0, 37, 811);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, unreachableCodeElimination0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertFalse(node1.isGetterDef());
  }

  @Test(timeout = 4000)
  public void test27()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("l+dI-_");
      PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager(mockPrintStream0);
      Compiler compiler0 = new Compiler(printStreamErrorManager0);
      UnreachableCodeElimination unreachableCodeElimination0 = new UnreachableCodeElimination(compiler0, false);
      Node node0 = compiler0.parseTestCode("finally");
      Node node1 = new Node(48, node0, node0, node0, node0, 65500, 124);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, unreachableCodeElimination0);
      CompilerOptions compilerOptions0 = compiler0.getOptions();
      CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
      TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node1, node1);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 48
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test28()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("l+dI-_");
      PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager(mockPrintStream0);
      Compiler compiler0 = new Compiler(printStreamErrorManager0);
      UnreachableCodeElimination unreachableCodeElimination0 = new UnreachableCodeElimination(compiler0, true);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, unreachableCodeElimination0);
      Node node0 = compiler0.parseTestCode("JSC_DETERMINISTIC_TEST");
      Node node1 = new Node(49, node0, node0, node0, node0, 4095, 8);
      CompilerOptions compilerOptions0 = compiler0.getOptions();
      CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
      TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertFalse(node1.isEmpty());
  }

  @Test(timeout = 4000)
  public void test29()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("l+dI-_");
      PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager(mockPrintStream0);
      Compiler compiler0 = new Compiler(printStreamErrorManager0);
      UnreachableCodeElimination unreachableCodeElimination0 = new UnreachableCodeElimination(compiler0, false);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, unreachableCodeElimination0);
      Node node0 = compiler0.parseTestCode("");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
      TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
      Node node1 = new Node(50, 46, 4095);
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node1, node0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 50
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test30()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("l+dI-_");
      PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager(mockPrintStream0);
      Compiler compiler0 = new Compiler(printStreamErrorManager0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      compiler0.initCompilerOptionsIfTesting();
      CheckLevel checkLevel0 = CheckLevel.WARNING;
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0, checkLevel0, checkLevel0);
      Node node0 = compiler0.parseTestCode("TightenTypes pass appears to be stuck in an infinite loop.");
      Node node1 = new Node(51, node0, node0, node0, node0, 1, 30);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertEquals(0, compiler0.getWarningCount());
      assertEquals(0, printStreamErrorManager0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test31()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("l+dI-_");
      PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager(mockPrintStream0);
      Compiler compiler0 = new Compiler(printStreamErrorManager0);
      UnreachableCodeElimination unreachableCodeElimination0 = new UnreachableCodeElimination(compiler0, true);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, unreachableCodeElimination0);
      Node node0 = compiler0.parseTestCode("JSC_UNKNOWN_OVERRIDE");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
      TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
      Node node1 = new Node(52, 36, 109);
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node1, node0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeCheck", e);
      }
  }

  @Test(timeout = 4000)
  public void test32()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("l+dI-_");
      PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager(mockPrintStream0);
      Compiler compiler0 = new Compiler(printStreamErrorManager0);
      UnreachableCodeElimination unreachableCodeElimination0 = new UnreachableCodeElimination(compiler0, false);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, unreachableCodeElimination0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      compiler0.initCompilerOptionsIfTesting();
      CheckLevel checkLevel0 = CheckLevel.WARNING;
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0, checkLevel0, checkLevel0);
      Node node0 = compiler0.parseTestCode("l+dI-_");
      Node node1 = new Node(53, 36, 40);
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node1, node0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 53
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test33()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("l+dI-_");
      PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager(mockPrintStream0);
      Compiler compiler0 = new Compiler(printStreamErrorManager0);
      UnreachableCodeElimination unreachableCodeElimination0 = new UnreachableCodeElimination(compiler0, true);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, unreachableCodeElimination0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      compiler0.initCompilerOptionsIfTesting();
      CheckLevel checkLevel0 = CheckLevel.OFF;
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0, checkLevel0, checkLevel0);
      Node node0 = compiler0.parseTestCode("JSC_UNKNOWN_OVERRIDE");
      Node node1 = new Node(54, node0, node0, node0, node0, (-2908), (-104));
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node1, node0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 54
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test34()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("l+dI-_");
      PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager(mockPrintStream0);
      Compiler compiler0 = new Compiler(printStreamErrorManager0);
      UnreachableCodeElimination unreachableCodeElimination0 = new UnreachableCodeElimination(compiler0, false);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, unreachableCodeElimination0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      compiler0.initCompilerOptionsIfTesting();
      CheckLevel checkLevel0 = CheckLevel.OFF;
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0, checkLevel0, checkLevel0);
      Node node0 = compiler0.parseTestCode("l+dI-_");
      Node node1 = new Node(55, node0, node0, node0, node0, 8, 47);
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node1, node0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 55
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test35()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("l+dI-_");
      PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager(mockPrintStream0);
      Compiler compiler0 = new Compiler(printStreamErrorManager0);
      UnreachableCodeElimination unreachableCodeElimination0 = new UnreachableCodeElimination(compiler0, true);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, unreachableCodeElimination0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      compiler0.initCompilerOptionsIfTesting();
      CheckLevel checkLevel0 = CheckLevel.OFF;
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0, checkLevel0, checkLevel0);
      JSType[] jSTypeArray0 = new JSType[0];
      Node node0 = jSTypeRegistry0.createParameters(jSTypeArray0);
      typeCheck0.visit(nodeTraversal0, node0, node0);
      assertFalse(node0.isThrow());
  }

  @Test(timeout = 4000)
  public void test36()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("l+dI-_");
      PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager(mockPrintStream0);
      Compiler compiler0 = new Compiler(printStreamErrorManager0);
      UnreachableCodeElimination unreachableCodeElimination0 = new UnreachableCodeElimination(compiler0, true);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, unreachableCodeElimination0);
      Node node0 = compiler0.parseTestCode("l+dI-_");
      Node node1 = new Node(87, node0, node0, node0, node0, 1400, 51);
      CompilerOptions compilerOptions0 = compiler0.getOptions();
      CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
      TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertFalse(compiler0.hasErrors());
      assertEquals(0, printStreamErrorManager0.getErrorCount());
  }

  @Test(timeout = 4000)
  public void test37()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("l+dI-_");
      PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager(mockPrintStream0);
      Compiler compiler0 = new Compiler(printStreamErrorManager0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      compiler0.initCompilerOptionsIfTesting();
      CheckLevel checkLevel0 = CheckLevel.ERROR;
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0, checkLevel0, checkLevel0);
      Node node0 = new Node(94, 94, 1713);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node0, node0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeCheck", e);
      }
  }

  @Test(timeout = 4000)
  public void test38()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("JSC_INTERFACE_FUNCTION_NOT_EMPTY");
      PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager(mockPrintStream0);
      Compiler compiler0 = new Compiler(printStreamErrorManager0);
      UnreachableCodeElimination unreachableCodeElimination0 = new UnreachableCodeElimination(compiler0, false);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, unreachableCodeElimination0);
      compiler0.initCompilerOptionsIfTesting();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
      TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
      Node node0 = new Node(101, 47, 32);
      typeCheck0.visit(nodeTraversal0, node0, node0);
      assertEquals(53, Node.INPUT_ID);
  }

  @Test(timeout = 4000)
  public void test39()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("l+dI-_");
      PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager(mockPrintStream0);
      Compiler compiler0 = new Compiler(printStreamErrorManager0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      compiler0.initCompilerOptionsIfTesting();
      CheckLevel checkLevel0 = CheckLevel.ERROR;
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0, checkLevel0, checkLevel0);
      Node node0 = new Node(102, 102, 1713);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node0, node0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeCheck", e);
      }
  }

  @Test(timeout = 4000)
  public void test40()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("l+dI-_");
      PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager(mockPrintStream0);
      Compiler compiler0 = new Compiler(printStreamErrorManager0);
      UnreachableCodeElimination unreachableCodeElimination0 = new UnreachableCodeElimination(compiler0, false);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, unreachableCodeElimination0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      compiler0.initCompilerOptionsIfTesting();
      CheckLevel checkLevel0 = CheckLevel.WARNING;
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0, checkLevel0, checkLevel0);
      Node node0 = compiler0.parseTestCode("l+dI-_");
      Node node1 = new Node(105, node0, node0, node0, node0, 1400, 51);
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node1, node1);
        fail("Expecting exception: UnsupportedOperationException");
      
      } catch(UnsupportedOperationException e) {
         //
         // SCRIPT 1 [synthetic: com.google.javascript.rhino.Node$IntPropListItem@0000001258] [source_file: com.google.javascript.rhino.Node$ObjectPropListItem@0000001259] [input_id: com.google.javascript.rhino.Node$ObjectPropListItem@0000001260] is not a string node
         //
         verifyException("com.google.javascript.rhino.Node", e);
      }
  }

  @Test(timeout = 4000)
  public void test41()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("l+dI-_");
      PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager(mockPrintStream0);
      Compiler compiler0 = new Compiler(printStreamErrorManager0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      compiler0.initCompilerOptionsIfTesting();
      CheckLevel checkLevel0 = CheckLevel.OFF;
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0, checkLevel0, checkLevel0);
      Node node0 = compiler0.parseTestCode("");
      Node node1 = new Node(107, node0, node0, node0, node0, 38, 149);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node1, node1);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 107
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test42()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("l+dI-_");
      PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager(mockPrintStream0);
      Compiler compiler0 = new Compiler(printStreamErrorManager0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      compiler0.initCompilerOptionsIfTesting();
      CheckLevel checkLevel0 = CheckLevel.ERROR;
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0, checkLevel0, checkLevel0);
      Node node0 = compiler0.parseSyntheticCode("l+dI-_", "l+dI-_");
      Node node1 = new Node(109, node0, node0, node0, node0, 38, 43);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node1, node1);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 109
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test43()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("l+dI-_");
      PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager(mockPrintStream0);
      Compiler compiler0 = new Compiler(printStreamErrorManager0);
      UnreachableCodeElimination unreachableCodeElimination0 = new UnreachableCodeElimination(compiler0, true);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, unreachableCodeElimination0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      compiler0.initCompilerOptionsIfTesting();
      CheckLevel checkLevel0 = CheckLevel.WARNING;
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0, checkLevel0, checkLevel0);
      Node node0 = compiler0.parseTestCode("l+dI-_");
      Node node1 = new Node(110, node0, node0, node0, node0, 1400, 51);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertFalse(node1.isDefaultCase());
  }

  @Test(timeout = 4000)
  public void test44()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("l+dI-_");
      PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager(mockPrintStream0);
      Compiler compiler0 = new Compiler(printStreamErrorManager0);
      UnreachableCodeElimination unreachableCodeElimination0 = new UnreachableCodeElimination(compiler0, true);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, unreachableCodeElimination0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      compiler0.initCompilerOptionsIfTesting();
      CheckLevel checkLevel0 = CheckLevel.WARNING;
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0, checkLevel0, checkLevel0);
      Node node0 = compiler0.parseTestCode("l+dI-_");
      Node node1 = new Node(111, node0, node0, node0, node0, 43, 32);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertFalse(node1.isLabelName());
  }

  @Test(timeout = 4000)
  public void test45()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      UnreachableCodeElimination unreachableCodeElimination0 = new UnreachableCodeElimination(compiler0, true);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      Node node0 = compiler0.parseTestCode("");
      Node node1 = new Node(112, node0, node0, node0, node0, 8232, 38);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, unreachableCodeElimination0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(42, Node.SIDE_EFFECT_FLAGS);
  }

  @Test(timeout = 4000)
  public void test46()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("l+dI-_");
      PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager(mockPrintStream0);
      Compiler compiler0 = new Compiler(printStreamErrorManager0);
      UnreachableCodeElimination unreachableCodeElimination0 = new UnreachableCodeElimination(compiler0, true);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, unreachableCodeElimination0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      // Undeclared exception!
      try { 
        compiler0.parseTestCode("l+dI-_");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // duplicate key: struct
         //
         verifyException("com.google.common.base.Preconditions", e);
      }
  }

  @Test(timeout = 4000)
  public void test47()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("l+dI-_");
      PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager(mockPrintStream0);
      Compiler compiler0 = new Compiler(printStreamErrorManager0);
      UnreachableCodeElimination unreachableCodeElimination0 = new UnreachableCodeElimination(compiler0, true);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, unreachableCodeElimination0);
      Node node0 = compiler0.parseTestCode("");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Node node1 = new Node(114, node0, node0, node0, node0, (-1298), 38);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, (JSTypeRegistry) null, compilerOptions0.aggressiveVarCheck, compilerOptions0.brokenClosureRequiresLevel);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(30, Node.VAR_ARGS_NAME);
  }

  @Test(timeout = 4000)
  public void test48()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("l+dI-_");
      PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager(mockPrintStream0);
      Compiler compiler0 = new Compiler(printStreamErrorManager0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention(closureCodingConvention0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
      compiler0.initCompilerOptionsIfTesting();
      CheckLevel checkLevel0 = CheckLevel.ERROR;
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0, checkLevel0, checkLevel0);
      Node node0 = new Node(115, 119, 119);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
      typeCheck0.visit(nodeTraversal0, node0, node0);
      assertEquals(50, Node.FREE_CALL);
  }

  @Test(timeout = 4000)
  public void test49()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("l+dI-_");
      PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager(mockPrintStream0);
      Compiler compiler0 = new Compiler(printStreamErrorManager0);
      UnreachableCodeElimination unreachableCodeElimination0 = new UnreachableCodeElimination(compiler0, true);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, unreachableCodeElimination0);
      compiler0.parseTestCode("`RCq$KhQN3e^K");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
      TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
      Node node0 = new Node(116, 117, 32);
      typeCheck0.visit(nodeTraversal0, node0, node0);
      assertFalse(node0.isFunction());
  }

  @Test(timeout = 4000)
  public void test50()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("l+dI-_");
      PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager(mockPrintStream0);
      Compiler compiler0 = new Compiler(printStreamErrorManager0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      compiler0.initCompilerOptionsIfTesting();
      CheckLevel checkLevel0 = CheckLevel.ERROR;
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0, checkLevel0, checkLevel0);
      Node node0 = new Node(119, 119, 119);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node0, node0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeCheck", e);
      }
  }

  @Test(timeout = 4000)
  public void test51()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("l+dI-_");
      PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager(mockPrintStream0);
      Compiler compiler0 = new Compiler(printStreamErrorManager0);
      UnreachableCodeElimination unreachableCodeElimination0 = new UnreachableCodeElimination(compiler0, true);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, unreachableCodeElimination0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      compiler0.initCompilerOptionsIfTesting();
      CheckLevel checkLevel0 = CheckLevel.WARNING;
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0, checkLevel0, checkLevel0);
      Node node0 = compiler0.parseTestCode("l+dI-_");
      Node node1 = new Node(120, node0, node0, node0, node0, 1400, 51);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertEquals(42, Node.SIDE_EFFECT_FLAGS);
  }

  @Test(timeout = 4000)
  public void test52()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("l+dI-_");
      PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager(mockPrintStream0);
      Compiler compiler0 = new Compiler(printStreamErrorManager0);
      UnreachableCodeElimination unreachableCodeElimination0 = new UnreachableCodeElimination(compiler0, true);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, unreachableCodeElimination0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      compiler0.initCompilerOptionsIfTesting();
      CheckLevel checkLevel0 = CheckLevel.OFF;
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0, checkLevel0, checkLevel0);
      Node node0 = compiler0.parseTestCode("");
      Node node1 = new Node(122, node0, node0, node0, node0, 4, 4);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertFalse(node0.isCatch());
  }

  @Test(timeout = 4000)
  public void test53()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("l+dI-_");
      PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager(mockPrintStream0);
      Compiler compiler0 = new Compiler(printStreamErrorManager0);
      UnreachableCodeElimination unreachableCodeElimination0 = new UnreachableCodeElimination(compiler0, false);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, unreachableCodeElimination0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      compiler0.initCompilerOptionsIfTesting();
      CheckLevel checkLevel0 = CheckLevel.OFF;
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0, checkLevel0, checkLevel0);
      Node node0 = compiler0.parseTestCode("");
      Node node1 = new Node(123, node0, node0, node0, node0, 1, 54);
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node1, node1);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 123
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test54()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("l+dI-_");
      PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager(mockPrintStream0);
      Compiler compiler0 = new Compiler(printStreamErrorManager0);
      UnreachableCodeElimination unreachableCodeElimination0 = new UnreachableCodeElimination(compiler0, false);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      Node node0 = compiler0.parseTestCode("l+dI-_");
      Node node1 = new Node(128, node0, node0, node0, node0, 49, 126);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node1, node0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 128
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test55()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("l+dI-_");
      PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager(mockPrintStream0);
      Compiler compiler0 = new Compiler(printStreamErrorManager0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention(closureCodingConvention0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
      compiler0.initCompilerOptionsIfTesting();
      CheckLevel checkLevel0 = CheckLevel.OFF;
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0, checkLevel0, checkLevel0);
      Node node0 = compiler0.parseTestCode("");
      Node node1 = new Node(129, node0, node0, node0, node0, 52, (-1709));
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node1, node0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 129
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test56()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("l+dI-_");
      PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager(mockPrintStream0);
      Compiler compiler0 = new Compiler(printStreamErrorManager0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      compiler0.initCompilerOptionsIfTesting();
      CheckLevel checkLevel0 = CheckLevel.ERROR;
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0, checkLevel0, checkLevel0);
      Node node0 = compiler0.parseTestCode("");
      Node node1 = new Node(131, node0, node0, node0, node0, 38, 149);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node1, node1);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 131
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test57()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      UnreachableCodeElimination unreachableCodeElimination0 = new UnreachableCodeElimination(compiler0, true);
      Node node0 = compiler0.parseTestCode("");
      Node node1 = new Node(133, node0, node0, node0, node0, 4095, 38);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, unreachableCodeElimination0);
      CompilerOptions compilerOptions0 = compiler0.getOptions();
      CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
      TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node1, node1);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 133
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test58()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("l+dI-_");
      PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager(mockPrintStream0);
      Compiler compiler0 = new Compiler(printStreamErrorManager0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      compiler0.initCompilerOptionsIfTesting();
      CheckLevel checkLevel0 = CheckLevel.ERROR;
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0, checkLevel0, checkLevel0);
      Node node0 = new Node(94, 94, 1713);
      Node node1 = new Node(135, node0, node0, node0, node0, 1, (-4691));
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node1, node1);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 135
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test59()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("l+dI-_");
      PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager(mockPrintStream0);
      Compiler compiler0 = new Compiler(printStreamErrorManager0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, (NodeTraversal.Callback) null);
      compiler0.parseTestCode("l+dI-_");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
      TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
      Node node0 = new Node(139, 30, 4095);
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node0, node0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 139
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test60()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("l+dI-_");
      PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager(mockPrintStream0);
      Compiler compiler0 = new Compiler(printStreamErrorManager0);
      Node node0 = compiler0.parseTestCode("zAnB&");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
      TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
      Node node1 = new Node(141, 8181, 17);
      UnreachableCodeElimination unreachableCodeElimination0 = new UnreachableCodeElimination(compiler0, false);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, unreachableCodeElimination0, (ScopeCreator) null);
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node1, node0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 141
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test61()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("l+dI-_");
      PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager(mockPrintStream0);
      Compiler compiler0 = new Compiler(printStreamErrorManager0);
      UnreachableCodeElimination unreachableCodeElimination0 = new UnreachableCodeElimination(compiler0, false);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, unreachableCodeElimination0);
      Node node0 = compiler0.parseTestCode("l+dI-_");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
      TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
      Node node1 = new Node(143, 1, 39);
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node1, node0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 143
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test62()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("l+dI-_");
      PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager(mockPrintStream0);
      Compiler compiler0 = new Compiler(printStreamErrorManager0);
      UnreachableCodeElimination unreachableCodeElimination0 = new UnreachableCodeElimination(compiler0, false);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention(closureCodingConvention0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
      compiler0.initCompilerOptionsIfTesting();
      CheckLevel checkLevel0 = CheckLevel.OFF;
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, unreachableCodeElimination0, (ScopeCreator) null);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0, checkLevel0, checkLevel0);
      Node node0 = compiler0.parseTestCode("");
      Node node1 = new Node(144, node0, node0, node0, node0, (-2088), (-2278));
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node1, node1);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 144
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test63()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("l+dI-_");
      PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager(mockPrintStream0);
      Compiler compiler0 = new Compiler(printStreamErrorManager0);
      UnreachableCodeElimination unreachableCodeElimination0 = new UnreachableCodeElimination(compiler0, true);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, unreachableCodeElimination0);
      compiler0.initCompilerOptionsIfTesting();
      CompilerOptions compilerOptions0 = compiler0.getOptions();
      CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
      TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
      Node node0 = new Node(145, 17, 14);
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node0, node0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 145
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test64()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("l+dI-_");
      PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager(mockPrintStream0);
      Compiler compiler0 = new Compiler(printStreamErrorManager0);
      UnreachableCodeElimination unreachableCodeElimination0 = new UnreachableCodeElimination(compiler0, false);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      compiler0.initCompilerOptionsIfTesting();
      CheckLevel checkLevel0 = CheckLevel.OFF;
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0, checkLevel0, checkLevel0);
      Node node0 = compiler0.parseTestCode("");
      Node node1 = new Node(148, node0, node0, node0, node0, 16, 49);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, unreachableCodeElimination0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(47, Node.IS_DISPATCHER);
  }

  @Test(timeout = 4000)
  public void test65()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      UnreachableCodeElimination unreachableCodeElimination0 = new UnreachableCodeElimination(compiler0, true);
      Node node0 = compiler0.parseTestCode("");
      Node node1 = new Node(150, node0, node0, node0, node0, 4095, 38);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, unreachableCodeElimination0);
      CompilerOptions compilerOptions0 = compiler0.options;
      CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
      TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node1, node1);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 150
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test66()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("l+dI-");
      PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager(mockPrintStream0);
      Compiler compiler0 = new Compiler(printStreamErrorManager0);
      compiler0.initCompilerOptionsIfTesting();
      Node node0 = new Node(151, 151, (-1557));
      CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
      CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
      TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node0, node0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 151
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test67()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("l+dI-_");
      PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager(mockPrintStream0);
      Compiler compiler0 = new Compiler(printStreamErrorManager0);
      UnreachableCodeElimination unreachableCodeElimination0 = new UnreachableCodeElimination(compiler0, true);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention(closureCodingConvention0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
      compiler0.initCompilerOptionsIfTesting();
      CheckLevel checkLevel0 = CheckLevel.OFF;
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0, checkLevel0, checkLevel0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, unreachableCodeElimination0);
      Node node0 = new Node(155, 38, 155);
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node0, node0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeCheck", e);
      }
  }

  @Test(timeout = 4000)
  public void test68()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      UnreachableCodeElimination unreachableCodeElimination0 = new UnreachableCodeElimination(compiler0, true);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, unreachableCodeElimination0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      compiler0.initCompilerOptionsIfTesting();
      CheckLevel checkLevel0 = CheckLevel.WARNING;
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0, checkLevel0, checkLevel0);
      Node node0 = compiler0.parseTestCode("l+dI-_");
      Node node1 = new Node(4095, 38, 106);
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node1, node0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 4095
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test69()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("l+dI-_");
      PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager(mockPrintStream0);
      Compiler compiler0 = new Compiler(printStreamErrorManager0);
      UnreachableCodeElimination unreachableCodeElimination0 = new UnreachableCodeElimination(compiler0, true);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, unreachableCodeElimination0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      compiler0.initCompilerOptionsIfTesting();
      CheckLevel checkLevel0 = CheckLevel.WARNING;
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0, checkLevel0, checkLevel0);
      Node node0 = compiler0.parseTestCode("l+dI-_");
      Node node1 = new Node(120, node0, node0, node0, node0, 1400, 51);
      boolean boolean0 = typeCheck0.visitName(nodeTraversal0, node0, node1);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void test70()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("l+dI-_");
      PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager(mockPrintStream0);
      Compiler compiler0 = new Compiler(printStreamErrorManager0);
      UnreachableCodeElimination unreachableCodeElimination0 = new UnreachableCodeElimination(compiler0, true);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention(closureCodingConvention0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
      compiler0.initCompilerOptionsIfTesting();
      CheckLevel checkLevel0 = CheckLevel.ERROR;
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, unreachableCodeElimination0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0, checkLevel0, checkLevel0);
      Node node0 = new Node(151, 151, (-1557));
      ArrayList<JSType> arrayList0 = new ArrayList<JSType>();
      Node node1 = jSTypeRegistry0.createParameters((List<JSType>) arrayList0);
      boolean boolean0 = typeCheck0.visitName(nodeTraversal0, node0, node1);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void test71()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("l+dI-_");
      PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager(mockPrintStream0);
      Compiler compiler0 = new Compiler(printStreamErrorManager0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      compiler0.initCompilerOptionsIfTesting();
      CheckLevel checkLevel0 = CheckLevel.ERROR;
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0, checkLevel0, checkLevel0);
      Node node0 = compiler0.parseTestCode("l+dI-_");
      Node node1 = new Node(97, node0, node0, node0, node0, 46, 1397);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      node1.addSuppression("l+dI-_");
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertTrue(compiler0.hasErrors());
      assertEquals(1, printStreamErrorManager0.getErrorCount());
  }

  @Test(timeout = 4000)
  public void test72()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("l+dI-_");
      PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager(mockPrintStream0);
      Compiler compiler0 = new Compiler(printStreamErrorManager0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      compiler0.initCompilerOptionsIfTesting();
      CheckLevel checkLevel0 = CheckLevel.ERROR;
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0, checkLevel0, checkLevel0);
      double double0 = typeCheck0.getTypedPercent();
      assertEquals(0.0, double0, 0.01);
  }
}
