/*
 * This file was automatically generated by EvoSuite
 * Sat Jul 29 18:20:40 GMT 2023
 */

package com.google.javascript.jscomp;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import com.google.common.collect.Multimap;
import com.google.javascript.jscomp.ClosureCodingConvention;
import com.google.javascript.jscomp.ClosureReverseAbstractInterpreter;
import com.google.javascript.jscomp.Compiler;
import com.google.javascript.jscomp.ControlFlowGraph;
import com.google.javascript.jscomp.FlowScope;
import com.google.javascript.jscomp.GoogleCodingConvention;
import com.google.javascript.jscomp.LinkedFlowScope;
import com.google.javascript.jscomp.ReverseAbstractInterpreter;
import com.google.javascript.jscomp.Scope;
import com.google.javascript.jscomp.SemanticReverseAbstractInterpreter;
import com.google.javascript.jscomp.TypeInference;
import com.google.javascript.jscomp.TypedScopeCreator;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.SimpleErrorReporter;
import com.google.javascript.rhino.jstype.BooleanLiteralSet;
import com.google.javascript.rhino.jstype.FunctionType;
import com.google.javascript.rhino.jstype.JSType;
import com.google.javascript.rhino.jstype.JSTypeRegistry;
import com.google.javascript.rhino.jstype.ObjectType;
import java.util.ArrayList;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.TreeSet;
import java.util.Vector;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class TypeInference_ESTest extends TypeInference_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void test00()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newNumber(1559.3560944773787, 773, 5);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      Scope scope0 = new Scope(node0, (ObjectType) null);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      Node node1 = new Node(101, node0, 31, 22);
      FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
      assertNotSame(flowScope1, flowScope0);
  }

  @Test(timeout = 4000)
  public void test01()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newNumber(3839.3739670437067, 2552, 2552);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node0, (ObjectType) null);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, treeSet0);
      Multimap<Scope, Scope.Var> multimap0 = typeInference0.getAssignedOuterLocalVars();
      assertNotNull(multimap0);
  }

  @Test(timeout = 4000)
  public void test02()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newNumber((double) 0L, 2552, 2552);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node0, (ObjectType) null);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
      Node node1 = new Node(33, node0, 41, 19);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: UnsupportedOperationException");
      
      } catch(UnsupportedOperationException e) {
         //
         // NUMBER 0.0 2552 : com.google.javascript.rhino.jstype.NumberType@0000000041 is not a string node
         //
         verifyException("com.google.javascript.rhino.Node", e);
      }
  }

  @Test(timeout = 4000)
  public void test03()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newNumber((double) 0L, 2552, 2552);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node0, (ObjectType) null);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(120);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test04()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newNumber((-363.0), (-319), 4410);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      Scope scope0 = new Scope(node0, (ObjectType) null);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
      arrayList0.add((Scope.Var) null);
      TypeInference typeInference0 = null;
      try {
        typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, arrayList0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test05()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newNumber(3839.3739670437067, 2552, 2552);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0);
  }

  @Test(timeout = 4000)
  public void test06()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newNumber(3839.3739670437067, 2552, 2552);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node0, (ObjectType) null);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, treeSet0);
      FlowScope flowScope0 = typeInference0.createInitialEstimateLattice();
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, flowScope0);
      assertTrue(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void test07()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newNumber((double) 0L, 2552, 2552);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_TRUE;
      controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node0, (ObjectType) null);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // NUMBER 0.0 2552 : com.google.javascript.rhino.jstype.NumberType@0000000041 does not have a condition.
         //
         verifyException("com.google.javascript.jscomp.NodeUtil", e);
      }
  }

  @Test(timeout = 4000)
  public void test08()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newNumber((double) (-1393), 160, (-1393));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_FALSE;
      controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node0, (ObjectType) null);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // NUMBER -1393.0 : com.google.javascript.rhino.jstype.NumberType@0000000041 does not have a condition.
         //
         verifyException("com.google.javascript.jscomp.NodeUtil", e);
      }
  }

  @Test(timeout = 4000)
  public void test09()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newNumber((-363.0), (-319), 4410);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      Scope scope0 = new Scope(node0, (ObjectType) null);
      Node node1 = new Node(4, node0, 18, 2);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, arrayList0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // RETURN 18 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test10()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newNumber((double) (-1408), 160, (-1408));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
      Scope scope0 = new Scope(node0, objectType0);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, treeSet0);
      Node node1 = new Node(5, node0, node0, node0, 2005, (-2));
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test11()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newNumber((double) (-1408), 160, (-1408));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
      Scope scope0 = new Scope(node0, objectType0);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, treeSet0);
      Node node1 = new Node(6, node0, node0, node0, 1, 1);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // IFEQ 1 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test12()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newNumber((double) 0L, 2552, 2552);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node0, (ObjectType) null);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
      Node node1 = new Node(7, node0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test13()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = new Node(608);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      Scope scope0 = new Scope(node0, (ObjectType) null);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      Node node1 = new Node(8, node0, (-241), 1363);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeSet0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // SETNAME does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test14()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newNumber((double) 0L, 2552, 2552);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      Node node1 = new Node(9);
      Scope scope0 = new Scope(node0, compiler0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, treeSet0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // BITOR : com.google.javascript.rhino.jstype.NumberType@0000000041 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test15()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newNumber((double) 0L, 2552, 2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node0, (ObjectType) null);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
      Node node1 = new Node(10, node0, 43, (-3586));
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // BITXOR : com.google.javascript.rhino.jstype.NumberType@0000000041 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test16()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newNumber((double) 0L, (-145), 2766);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      Scope scope0 = new Scope(node0, (ObjectType) null);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      Node node1 = new Node(11, node0, 13, 2766);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeSet0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // BITAND 13 : com.google.javascript.rhino.jstype.NumberType@0000000041 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test17()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newNumber((double) 0L, 2552, 2552);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node0, (ObjectType) null);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
      Node node1 = new Node(12, node0, node0, node0, 102, (-64));
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // EQ : com.google.javascript.rhino.jstype.BooleanType@0000000039 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test18()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newNumber((double) (-1393), 160, (-1393));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
      FunctionType functionType0 = jSTypeRegistry0.createFunctionType((JSType) null, (List<JSType>) linkedList0);
      Scope scope0 = new Scope(node0, functionType0);
      Node node1 = Node.newString(13, "Named type with empty name component", 2, 9);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, arrayList0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // NE Named type with empty name component 2 : com.google.javascript.rhino.jstype.BooleanType@0000000039 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test19()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newNumber((double) 0L, 2552, 2552);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node0, (ObjectType) null);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = Node.newString(14, "", (-2), 37);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test20()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newNumber((double) 0L, 2552, 2552);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      Scope scope0 = new Scope(node0, (ObjectType) null);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      Node node1 = new Node(15);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeSet0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // LE : com.google.javascript.rhino.jstype.BooleanType@0000000039 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test21()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newNumber((double) (-1408), 160, (-1408));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
      Scope scope0 = new Scope(node0, objectType0);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, treeSet0);
      Node node1 = new Node(16, node0, node0, node0, 42, 4939);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test22()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = new Node((-3929));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null);
      Scope scope0 = new Scope(node0, (ObjectType) null);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeSet0);
      Node node1 = new Node(17, node0, 4095, 102);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // GE 4095 : com.google.javascript.rhino.jstype.BooleanType@0000000039 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test23()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newNumber((double) 0L, 2552, 2552);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
      Scope scope0 = new Scope(node0, objectType0);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, treeSet0);
      Node node1 = new Node(18, node0, (-4813), 12);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // LSH : com.google.javascript.rhino.jstype.NumberType@0000000041 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test24()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newNumber((double) 0L, (-319), 4410);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      Scope scope0 = new Scope(node0, (ObjectType) null);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      Node node1 = new Node(19);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeSet0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // RSH : com.google.javascript.rhino.jstype.NumberType@0000000041 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test25()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newNumber((double) 0L, 2552, 2552);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node0, (ObjectType) null);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, treeSet0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(20);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // URSH : com.google.javascript.rhino.jstype.NumberType@0000000041 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test26()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newNumber((double) 0L, 128, (-1));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node0, (ObjectType) null);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
      Node node1 = new Node(21, node0, (-2915), 635);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test27()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newNumber((double) 0L, (-1408), (-1408));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      Scope scope0 = new Scope(node0, (ObjectType) null);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, treeSet0);
      Node node1 = new Node(22, node0, 89, 58);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // SUB 89 : com.google.javascript.rhino.jstype.NumberType@0000000041 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test28()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newNumber((double) 0L, 128, (-1));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node0, (ObjectType) null);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
      Node node1 = new Node(23, node0, 119, 13);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // MUL 119 : com.google.javascript.rhino.jstype.NumberType@0000000041 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test29()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newNumber((double) (-1408), 160, (-1408));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
      Scope scope0 = new Scope(node0, objectType0);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, treeSet0);
      Node node1 = new Node(24, node0, node0, node0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test30()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newNumber((double) 4410, (-319), (-319));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      Scope scope0 = new Scope(node0, (ObjectType) null);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeSet0);
      Node[] nodeArray0 = new Node[1];
      nodeArray0[0] = node0;
      Node node1 = new Node(25, nodeArray0, 24, 11);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // MOD 24 : com.google.javascript.rhino.jstype.NumberType@0000000041 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test31()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newNumber((double) 0L, 2552, 2552);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node0, (ObjectType) null);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
      Node[] nodeArray0 = new Node[1];
      nodeArray0[0] = node0;
      Node node1 = new Node(26, nodeArray0, 43, 2);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // NOT 43 : com.google.javascript.rhino.jstype.BooleanType@0000000039 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test32()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newNumber((-2048.8792594642973), 2552, 8);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node0, (ObjectType) null);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
      Node node1 = new Node(27, node0, 42, 95);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // BITNOT 42 : com.google.javascript.rhino.jstype.NumberType@0000000041 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test33()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newNumber((double) 0L, 2552, 2552);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node0, (ObjectType) null);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, treeSet0);
      Node node1 = new Node(28, node0, 2, 83);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // POS 2 : com.google.javascript.rhino.jstype.NumberType@0000000041 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test34()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newNumber((double) 0L, 2552, 2552);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node0, (ObjectType) null);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
      Node node1 = new Node(29, node0, 65279, 49);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test35()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newNumber((double) (-1393), 160, (-1393));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
      FunctionType functionType0 = jSTypeRegistry0.createFunctionType((JSType) null, (List<JSType>) linkedList0);
      Scope scope0 = new Scope(node0, functionType0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, arrayList0);
      Node node1 = new Node(30);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test36()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newNumber((double) 0L, 2552, 2552);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node0, (ObjectType) null);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
      Node node1 = new Node(31, node0, 155, (-25));
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // DELPROP does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test37()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newNumber((-363.0), (-319), 4410);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      Scope scope0 = new Scope(node0, (ObjectType) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, arrayList0);
      Node node1 = new Node(32, node0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // TYPEOF : com.google.javascript.rhino.jstype.StringType@0000000042 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test38()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newNumber((double) (-1408), 160, (-1408));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node0, (ObjectType) null);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
      Node node1 = new Node(34, node0, 12, 48);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // SETPROP 12 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test39()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newNumber((double) (-1408), 160, (-1408));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      Scope scope0 = new Scope(node0, (ObjectType) null);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, treeSet0);
      Node node1 = new Node(36, node0, 106, 51);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // SETELEM 106 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test40()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newNumber((double) 4410, (-319), (-319));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      Scope scope0 = new Scope(node0, (ObjectType) null);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      Node node1 = new Node(37, node0, 93, 17);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeSet0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // CALL 93 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test41()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newNumber((double) 0L, 2552, 2552);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node0, (ObjectType) null);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Vector<JSType> vector0 = new Vector<JSType>();
      vector0.add((JSType) null);
      Node node1 = jSTypeRegistry0.createParameters((List<JSType>) vector0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // LP : com.google.javascript.rhino.jstype.UnknownType@0000000043 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test42()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newNumber((double) 0L, (-145), 2766);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      Scope scope0 = new Scope(node0, (ObjectType) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, arrayList0);
      Node node1 = Node.newString("sR@;e*:N2judYbB", 933, 119);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // STRING sR@;e*:N2judYbB 933 : com.google.javascript.rhino.jstype.StringType@0000000042 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test43()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newNumber((double) 0L, 2552, 2552);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node0, (ObjectType) null);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, treeSet0);
      Node node1 = new Node(41, node0, node0, node0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // NULL : com.google.javascript.rhino.jstype.NullType@0000000040 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test44()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = new Node(608);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      Scope scope0 = new Scope(node0, (ObjectType) null);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      Node node1 = new Node(42);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeSet0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // THIS does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test45()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newNumber((double) 4410, (-319), (-319));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      Scope scope0 = new Scope(node0, (ObjectType) null);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeSet0);
      Node node1 = new Node(43, node0, 1, 4);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // FALSE 1 : com.google.javascript.rhino.jstype.BooleanType@0000000039 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test46()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newNumber((double) 0L, (-1408), (-1408));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
      Scope scope0 = new Scope(node0, objectType0);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, treeSet0);
      Node node1 = new Node(44, node0, node0, node0, 40, 46);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // TRUE 40 : com.google.javascript.rhino.jstype.BooleanType@0000000039 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test47()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newNumber((double) 0L, 2552, 2552);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      Scope scope0 = new Scope(node0, (ObjectType) null);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, treeSet0);
      Node node1 = new Node(45, node0, node0, node0, 46, 2);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test48()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newNumber((double) 185, (-773), 185);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      Scope scope0 = new Scope(node0, (ObjectType) null);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      Node node1 = new Node(47);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeSet0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // OBJECT : com.google.javascript.rhino.jstype.InstanceObjectType@0000000206 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test49()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newNumber((double) 0L, 2552, 2552);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node0, (ObjectType) null);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
      Node node1 = new Node(48, node0, node0, node0, 5, 13);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // BINDNAME 5 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test50()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newNumber((double) (-1408), 160, (-1408));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      Scope scope0 = new Scope(node0, (ObjectType) null);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, treeSet0);
      Node node1 = new Node(49, node0, node0, node0, 23, 170);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // THROW 23 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test51()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newNumber((-2270.228), 37, 37);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      Scope scope0 = new Scope(node0, (ObjectType) null);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      Node node1 = new Node(88, node0, 31, 3);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeSet0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // ASSIGN_BITXOR 31 : com.google.javascript.rhino.jstype.NumberType@0000000041 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test52()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newNumber((double) 0L, 128, (-1));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node0, (ObjectType) null);
      Node node1 = new Node(93, node0, 787, (-2));
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedHashSet<Scope.Var> linkedHashSet0 = new LinkedHashSet<Scope.Var>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, linkedHashSet0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test53()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newNumber((double) 0L, 2552, 2552);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      Node node1 = new Node(98);
      Scope scope0 = new Scope(node1, compiler0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, treeSet0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test54()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newNumber((double) 0L, 2552, 2552);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node0, (ObjectType) null);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, treeSet0);
      Node node1 = new Node(99, node0, 24, 69);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // COLON 24 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test55()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newNumber((double) 0L, 2552, 2552);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      Scope scope0 = new Scope(node0, (ObjectType) null);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, treeSet0);
      Node node1 = new Node(105, node0, 15, 38);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test56()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newNumber((double) (-1408), 160, (-1408));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
      Scope scope0 = new Scope(node0, objectType0);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, treeSet0);
      Node node1 = new Node(106, node0, node0, node0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test57()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newNumber((double) 0L, 2552, 2552);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node0, (ObjectType) null);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, treeSet0);
      Node node1 = new Node(109, node0, node0, node0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test58()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newNumber((double) 0L, 2552, 2552);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node0, (ObjectType) null);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, treeSet0);
      Node node1 = new Node(111, node0, 36, 38);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // CASE 36 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test59()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newNumber((double) 0L, 2552, 2552);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      Scope scope0 = new Scope(node0, (ObjectType) null);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, treeSet0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(112);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // DEFAULT does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test60()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newNumber((double) (-1393), 160, (-1393));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      Scope scope0 = new Scope(node0, (ObjectType) null);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeSet0);
      Node node1 = new Node(113, node0, (-2047), (-379));
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // WHILE does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test61()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newNumber((double) 4410, (-319), (-319));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      Scope scope0 = new Scope(node0, (ObjectType) null);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      Node node1 = new Node(114, node0, 24, 4);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // DO 24 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test62()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newNumber((double) (-1408), (-1408), (-1408));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
      Scope scope0 = new Scope(node0, objectType0);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, treeSet0);
      Node node1 = new Node(117, node0, node0, node0, 42, 41);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test63()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newNumber((double) 0L, 2552, 2552);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node0, (ObjectType) null);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(118);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // VAR does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test64()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newNumber((double) (-1408), 160, (-1408));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
      Scope scope0 = new Scope(node0, objectType0);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, treeSet0);
      Node node1 = new Node(119, node0, 85, 4095);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // WITH 85 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test65()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newNumber((double) 0L, 2552, 2552);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node0, (ObjectType) null);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
      Node node1 = new Node(121, node0, 7, 12);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // FINALLY 7 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test66()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newNumber((double) (-1408), 160, (-1408));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
      Scope scope0 = new Scope(node0, objectType0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
      Node node1 = new Node(123, node0, 28, 2);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // RESERVED 28 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test67()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newNumber((double) (-1393), 160, (-1393));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
      FunctionType functionType0 = jSTypeRegistry0.createFunctionType((JSType) null, (List<JSType>) linkedList0);
      Scope scope0 = new Scope(node0, functionType0);
      Node node1 = new Node(124, node0, 11, 3131);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, arrayList0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // EMPTY 11 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test68()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newNumber((double) 0L, 2552, 2552);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node0, (ObjectType) null);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
      Node node1 = compiler0.parseSyntheticCode("<D2*[", "I`RSHOPm/U2r");
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // BLOCK [sourcename: java.lang.String@0000000679] does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test69()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newNumber((double) (-1408), 160, (-1408));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
      Scope scope0 = new Scope(node0, objectType0);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, treeSet0);
      Node node1 = new Node(127, node0, node0, node0, 42, 4939);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test70()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newNumber((double) 0L, 2552, 2552);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node0, (ObjectType) null);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
      Node node1 = new Node(128, node0, 33, 1);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // LOOP 33 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test71()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newNumber((double) 0L, 2552, 2552);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
      Scope scope0 = new Scope(node0, objectType0);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, treeSet0);
      Node node1 = Node.newString(129, "Not declared as a constructor");
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test72()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newNumber((double) (-1408), 160, (-1408));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
      Scope scope0 = new Scope(node0, objectType0);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, treeSet0);
      Node node1 = new Node(130, node0, 413, 14);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // EXPR_RESULT 413 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test73()  throws Throwable  {
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.EMPTY;
      BooleanLiteralSet booleanLiteralSet1 = TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet0, false);
      assertSame(booleanLiteralSet0, booleanLiteralSet1);
  }
}
