/*
 * This file was automatically generated by EvoSuite
 * Tue Sep 26 21:25:49 GMT 2023
 */

package com.google.javascript.jscomp;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import com.google.javascript.jscomp.CheckAccidentalSemicolon;
import com.google.javascript.jscomp.CheckLevel;
import com.google.javascript.jscomp.CheckRegExp;
import com.google.javascript.jscomp.ClosureReverseAbstractInterpreter;
import com.google.javascript.jscomp.CombinedCompilerPass;
import com.google.javascript.jscomp.Compiler;
import com.google.javascript.jscomp.CompilerInput;
import com.google.javascript.jscomp.DeadAssignmentsElimination;
import com.google.javascript.jscomp.DefaultCodingConvention;
import com.google.javascript.jscomp.MakeDeclaredNamesUnique;
import com.google.javascript.jscomp.NodeTraversal;
import com.google.javascript.jscomp.Scope;
import com.google.javascript.jscomp.ScopeCreator;
import com.google.javascript.jscomp.SourceInformationAnnotator;
import com.google.javascript.jscomp.TypeValidator;
import com.google.javascript.jscomp.TypedScopeCreator;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.SimpleErrorReporter;
import com.google.javascript.rhino.jstype.EnumElementType;
import com.google.javascript.rhino.jstype.EnumType;
import com.google.javascript.rhino.jstype.FunctionPrototypeType;
import com.google.javascript.rhino.jstype.FunctionType;
import com.google.javascript.rhino.jstype.JSType;
import com.google.javascript.rhino.jstype.JSTypeNative;
import com.google.javascript.rhino.jstype.JSTypeRegistry;
import com.google.javascript.rhino.jstype.NoType;
import com.google.javascript.rhino.jstype.ObjectType;
import com.google.javascript.rhino.jstype.StaticScope;
import java.util.ArrayList;
import java.util.List;
import java.util.Vector;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class TypeValidator_ESTest extends TypeValidator_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void test00()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      compiler0.parseSyntheticCode(", ", "only arrays or objects can be accessed");
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      Iterable<TypeValidator.TypeMismatch> iterable0 = typeValidator0.getMismatches();
      assertNotNull(iterable0);
  }

  @Test(timeout = 4000)
  public void test01()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      compiler0.parseSyntheticCode(", ", ", ");
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      typeValidator0.setShouldReport(false);
  }

  @Test(timeout = 4000)
  public void test02()  throws Throwable  {
      TypeValidator.TypeMismatch typeValidator_TypeMismatch0 = new TypeValidator.TypeMismatch((JSType) null, (JSType) null);
      String string0 = typeValidator_TypeMismatch0.toString();
      assertEquals("(null, null)", string0);
  }

  @Test(timeout = 4000)
  public void test03()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode(";7", ";7");
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      JSTypeNative jSTypeNative0 = JSTypeNative.NO_RESOLVED_TYPE;
      FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
      NodeTraversal.Callback[] nodeTraversal_CallbackArray0 = new NodeTraversal.Callback[0];
      CombinedCompilerPass combinedCompilerPass0 = new CombinedCompilerPass(compiler0, nodeTraversal_CallbackArray0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, combinedCompilerPass0);
      boolean boolean0 = typeValidator0.expectObject(nodeTraversal0, node0, functionType0, "Not declared as a constructor");
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void test04()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode(", ", ", ");
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      JSTypeNative jSTypeNative0 = JSTypeNative.ERROR_FUNCTION_TYPE;
      FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
      typeValidator0.expectActualObject((NodeTraversal) null, node0, functionType0, "Not declared as a constructor");
      assertFalse(functionType0.isNumberValueType());
  }

  @Test(timeout = 4000)
  public void test05()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode(", ", ", ");
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_STRING_BOOLEAN;
      JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[1];
      jSTypeNativeArray0[0] = jSTypeNative0;
      JSType jSType0 = jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
      // Undeclared exception!
      try { 
        typeValidator0.expectActualObject((NodeTraversal) null, node0, jSType0, "Not declared as a type name");
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeValidator", e);
      }
  }

  @Test(timeout = 4000)
  public void test06()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode(",6!", ",6!");
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      JSTypeNative jSTypeNative0 = JSTypeNative.ERROR_FUNCTION_TYPE;
      ObjectType objectType0 = jSTypeRegistry0.getNativeObjectType(jSTypeNative0);
      typeValidator0.expectAnyObject((NodeTraversal) null, node0, objectType0, ">eQ^");
      assertTrue(objectType0.hasCachedValues());
  }

  @Test(timeout = 4000)
  public void test07()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode(", ", ", ");
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_STRING_BOOLEAN;
      JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[1];
      jSTypeNativeArray0[0] = jSTypeNative0;
      JSType jSType0 = jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
      // Undeclared exception!
      try { 
        typeValidator0.expectAnyObject((NodeTraversal) null, node0, jSType0, "");
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeValidator", e);
      }
  }

  @Test(timeout = 4000)
  public void test08()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode(";7", "only arrays or objects can be accessed");
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      JSTypeNative jSTypeNative0 = JSTypeNative.NO_RESOLVED_TYPE;
      FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
      CheckLevel checkLevel0 = CheckLevel.WARNING;
      CheckAccidentalSemicolon checkAccidentalSemicolon0 = new CheckAccidentalSemicolon(checkLevel0);
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkAccidentalSemicolon0, typedScopeCreator0);
      typeValidator0.expectAnyObject(nodeTraversal0, node0, functionType0, "Not declared as a type name");
      assertTrue(functionType0.hasCachedValues());
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test09()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode(", ", ", ");
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      JSTypeNative jSTypeNative0 = JSTypeNative.FUNCTION_INSTANCE_TYPE;
      FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
      JSTypeNative jSTypeNative1 = JSTypeNative.NUMBER_STRING_BOOLEAN;
      JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[1];
      jSTypeNativeArray0[0] = jSTypeNative1;
      JSType jSType0 = jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
      typeValidator0.expectIndexMatch((NodeTraversal) null, node0, functionType0, jSType0);
      assertEquals(0, Node.SIDE_EFFECTS_ALL);
  }

  @Test(timeout = 4000)
  public void test10()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode(";7", "only arrays or objects can be accessed");
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      JSTypeNative jSTypeNative0 = JSTypeNative.NO_RESOLVED_TYPE;
      FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
      CheckLevel checkLevel0 = CheckLevel.WARNING;
      CheckAccidentalSemicolon checkAccidentalSemicolon0 = new CheckAccidentalSemicolon(checkLevel0);
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkAccidentalSemicolon0, typedScopeCreator0);
      typeValidator0.expectNumber(nodeTraversal0, node0, functionType0, "ASSIGN_LSH");
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test11()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode(", ", ", ");
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      JSTypeNative jSTypeNative0 = JSTypeNative.ERROR_FUNCTION_TYPE;
      FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
      MakeDeclaredNamesUnique makeDeclaredNamesUnique0 = new MakeDeclaredNamesUnique();
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, makeDeclaredNamesUnique0);
      typeValidator0.expectNumber(nodeTraversal0, node0, functionType0, "Named type with empty name component");
      assertTrue(functionType0.hasCachedValues());
      assertEquals(1, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test12()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      compiler0.initCompilerOptionsIfTesting();
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      JSTypeNative jSTypeNative0 = JSTypeNative.NO_OBJECT_TYPE;
      FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
      MakeDeclaredNamesUnique makeDeclaredNamesUnique0 = new MakeDeclaredNamesUnique();
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, makeDeclaredNamesUnique0);
      typeValidator0.expectBitwiseable(nodeTraversal0, (Node) null, functionType0, "Not declared as a constructor");
      assertFalse(functionType0.hasCachedValues());
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test13()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode(", ", ", ");
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      JSTypeNative jSTypeNative0 = JSTypeNative.ERROR_FUNCTION_TYPE;
      FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
      MakeDeclaredNamesUnique makeDeclaredNamesUnique0 = new MakeDeclaredNamesUnique();
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, makeDeclaredNamesUnique0);
      typeValidator0.expectBitwiseable(nodeTraversal0, node0, functionType0, "Not declared as a type name");
      assertTrue(functionType0.hasCachedValues());
      assertEquals(1, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test14()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode(";7", "only arrays or objects can be accessed");
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      JSTypeNative jSTypeNative0 = JSTypeNative.NO_RESOLVED_TYPE;
      FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
      CheckLevel checkLevel0 = CheckLevel.WARNING;
      CheckAccidentalSemicolon checkAccidentalSemicolon0 = new CheckAccidentalSemicolon(checkLevel0);
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkAccidentalSemicolon0, typedScopeCreator0);
      typeValidator0.expectStringOrNumber(nodeTraversal0, node0, functionType0, "Named type with empty name component");
      assertEquals((-3), Node.LOCAL_BLOCK_PROP);
  }

  @Test(timeout = 4000)
  public void test15()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode(", ", ", ");
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      JSTypeNative jSTypeNative0 = JSTypeNative.ERROR_FUNCTION_TYPE;
      FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
      SourceInformationAnnotator sourceInformationAnnotator0 = new SourceInformationAnnotator(", ", false);
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, sourceInformationAnnotator0, typedScopeCreator0);
      JSType jSType0 = jSTypeRegistry0.createNamedType("Named type with empty name component", "", 1337, 0);
      typeValidator0.expectIndexMatch(nodeTraversal0, node0, jSType0, functionType0);
      assertEquals(1, compiler0.getWarningCount());
      assertTrue(functionType0.hasCachedValues());
  }

  @Test(timeout = 4000)
  public void test16()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode(", ", ", ");
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      JSTypeNative jSTypeNative0 = JSTypeNative.FUNCTION_INSTANCE_TYPE;
      FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
      EnumType enumType0 = jSTypeRegistry0.createEnumType("JSC_HIDDEN_PROPERTY_MISMATCH", functionType0);
      EnumElementType enumElementType0 = enumType0.getElementsType();
      JSType jSType0 = enumElementType0.getPropertyType("*'-jP7YP");
      typeValidator0.expectIndexMatch((NodeTraversal) null, node0, jSType0, enumType0);
      assertFalse(enumType0.isResolved());
  }

  @Test(timeout = 4000)
  public void test17()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      compiler0.initCompilerOptionsIfTesting();
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
      JSType jSType0 = jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
      boolean boolean0 = typeValidator0.expectNotNullOrUndefined((NodeTraversal) null, (Node) null, jSType0, "Unknown class name", jSType0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void test18()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode(";7", "only arrays or objects can be accessed");
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      JSTypeNative jSTypeNative0 = JSTypeNative.NO_RESOLVED_TYPE;
      FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
      CheckLevel checkLevel0 = CheckLevel.WARNING;
      CheckAccidentalSemicolon checkAccidentalSemicolon0 = new CheckAccidentalSemicolon(checkLevel0);
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkAccidentalSemicolon0, typedScopeCreator0);
      boolean boolean0 = typeValidator0.expectNotNullOrUndefined(nodeTraversal0, node0, functionType0, "Not declared as a type name", functionType0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void test19()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      MakeDeclaredNamesUnique makeDeclaredNamesUnique0 = new MakeDeclaredNamesUnique();
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, makeDeclaredNamesUnique0);
      Node node0 = compiler0.parseSyntheticCode(", ", "");
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      JSType jSType0 = jSTypeRegistry0.getForgivingType((StaticScope<JSType>) null, "24%L", "", 19, 37);
      JSType jSType1 = closureReverseAbstractInterpreter0.getRestrictedWithoutNull(jSType0);
      boolean boolean0 = typeValidator0.expectNotNullOrUndefined(nodeTraversal0, node0, jSType1, "RL,HVG59:,vm", jSType0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void test20()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode(";7", "only arrays or objects can be accessed");
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      JSTypeNative jSTypeNative0 = JSTypeNative.NO_RESOLVED_TYPE;
      FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
      CheckLevel checkLevel0 = CheckLevel.WARNING;
      CheckAccidentalSemicolon checkAccidentalSemicolon0 = new CheckAccidentalSemicolon(checkLevel0);
      ObjectType objectType0 = jSTypeRegistry0.createObjectType("msg.set.prop.no.setter", node0, (ObjectType) functionType0);
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkAccidentalSemicolon0, typedScopeCreator0);
      boolean boolean0 = typeValidator0.expectNotNullOrUndefined(nodeTraversal0, node0, objectType0, "Not declared as a type name", objectType0);
      assertTrue(functionType0.hasCachedValues());
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void test21()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode(";7", "only arrays or objects can be accessed");
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      JSTypeNative jSTypeNative0 = JSTypeNative.NO_RESOLVED_TYPE;
      FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
      CheckLevel checkLevel0 = CheckLevel.WARNING;
      CheckAccidentalSemicolon checkAccidentalSemicolon0 = new CheckAccidentalSemicolon(checkLevel0);
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkAccidentalSemicolon0, typedScopeCreator0);
      typeValidator0.expectSwitchMatchesCase(nodeTraversal0, node0, functionType0, functionType0);
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test22()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode(" ", " ");
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      JSTypeNative jSTypeNative0 = JSTypeNative.FUNCTION_INSTANCE_TYPE;
      FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
      JSTypeNative jSTypeNative1 = JSTypeNative.NUMBER_STRING_BOOLEAN;
      JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[1];
      jSTypeNativeArray0[0] = jSTypeNative1;
      JSType jSType0 = jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
      // Undeclared exception!
      try { 
        typeValidator0.expectSwitchMatchesCase((NodeTraversal) null, node0, jSType0, functionType0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeValidator", e);
      }
  }

  @Test(timeout = 4000)
  public void test23()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode(", ", ", ");
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      JSTypeNative jSTypeNative0 = JSTypeNative.FUNCTION_INSTANCE_TYPE;
      FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
      JSTypeNative jSTypeNative1 = JSTypeNative.NUMBER_STRING_BOOLEAN;
      JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[1];
      jSTypeNativeArray0[0] = jSTypeNative1;
      JSType jSType0 = jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
      // Undeclared exception!
      try { 
        typeValidator0.expectIndexMatch((NodeTraversal) null, node0, jSType0, functionType0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeValidator", e);
      }
  }

  @Test(timeout = 4000)
  public void test24()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode(", ", "only arrays or objects can be accessed");
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      JSTypeNative jSTypeNative0 = JSTypeNative.ERROR_FUNCTION_TYPE;
      FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
      JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[1];
      jSTypeNativeArray0[0] = jSTypeNative0;
      JSType jSType0 = jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
      JSType jSType1 = jSTypeRegistry0.getGreatestSubtypeWithProperty(jSType0, "Not declared as a type name");
      boolean boolean0 = typeValidator0.expectCanAssignToPropertyOf((NodeTraversal) null, node0, functionType0, jSType1, node0, "Not declared as a type name");
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void test25()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode(", ", ", ");
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      JSTypeNative jSTypeNative0 = JSTypeNative.FUNCTION_INSTANCE_TYPE;
      FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
      boolean boolean0 = typeValidator0.expectCanAssignToPropertyOf((NodeTraversal) null, node0, functionType0, functionType0, node0, "Not declared as a type name");
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void test26()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode(", ", ", ");
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      MakeDeclaredNamesUnique makeDeclaredNamesUnique0 = new MakeDeclaredNamesUnique();
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, makeDeclaredNamesUnique0);
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
      ArrayList<JSType> arrayList0 = new ArrayList<JSType>();
      FunctionType functionType0 = jSTypeRegistry0.createFunctionType((JSType) objectType0, (List<JSType>) arrayList0);
      boolean boolean0 = typeValidator0.expectCanAssignToPropertyOf(nodeTraversal0, node0, objectType0, functionType0, node0, "Not declared as a type name");
      assertTrue(functionType0.hasCachedValues());
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void test27()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      compiler0.initCompilerOptionsIfTesting();
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      JSTypeNative jSTypeNative0 = JSTypeNative.FUNCTION_INSTANCE_TYPE;
      FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
      FunctionPrototypeType functionPrototypeType0 = functionType0.getPrototype();
      JSType.TypePair jSType_TypePair0 = functionPrototypeType0.getTypesUnderInequality(functionType0);
      boolean boolean0 = typeValidator0.expectCanAssignTo((NodeTraversal) null, (Node) null, jSType_TypePair0.typeA, jSType_TypePair0.typeA, "com.google.javascript.jscomp.AnalyzeNameReferences");
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void test28()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      compiler0.initCompilerOptionsIfTesting();
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      JSTypeNative jSTypeNative0 = JSTypeNative.ERROR_FUNCTION_TYPE;
      FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
      FunctionType functionType1 = jSTypeRegistry0.createFunctionTypeWithNewReturnType(functionType0, functionType0);
      boolean boolean0 = typeValidator0.expectCanAssignTo((NodeTraversal) null, (Node) null, functionType1, functionType0, "*OuLp_Y=;T");
      assertTrue(functionType0.hasCachedValues());
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void test29()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      compiler0.initCompilerOptionsIfTesting();
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      JSTypeNative jSTypeNative0 = JSTypeNative.ERROR_FUNCTION_TYPE;
      FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
      FunctionPrototypeType functionPrototypeType0 = functionType0.getPrototype();
      // Undeclared exception!
      try { 
        typeValidator0.expectCanAssignTo((NodeTraversal) null, (Node) null, functionType0, functionPrototypeType0, "*OuLp_Y=;T");
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeValidator", e);
      }
  }

  @Test(timeout = 4000)
  public void test30()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      compiler0.initCompilerOptionsIfTesting();
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      JSTypeNative jSTypeNative0 = JSTypeNative.NO_OBJECT_TYPE;
      FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
      FunctionPrototypeType functionPrototypeType0 = functionType0.getPrototype();
      JSType.TypePair jSType_TypePair0 = functionPrototypeType0.getTypesUnderInequality(functionType0);
      // Undeclared exception!
      try { 
        typeValidator0.expectCanAssignTo((NodeTraversal) null, (Node) null, functionPrototypeType0, jSType_TypePair0.typeB, "Named type with empty name component");
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeValidator", e);
      }
  }

  @Test(timeout = 4000)
  public void test31()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode(", ", ", ");
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      JSTypeNative jSTypeNative0 = JSTypeNative.ERROR_FUNCTION_TYPE;
      FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
      typeValidator0.expectArgumentMatchesParameter((NodeTraversal) null, node0, functionType0, functionType0, node0, 14);
      assertFalse(functionType0.isAllType());
  }

  @Test(timeout = 4000)
  public void test32()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      compiler0.initCompilerOptionsIfTesting();
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      JSTypeNative jSTypeNative0 = JSTypeNative.ERROR_FUNCTION_TYPE;
      FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
      typeValidator0.expectCanOverride((NodeTraversal) null, (Node) null, functionType0, functionType0, "Not declared as a constructor", functionType0);
      assertEquals(3, functionType0.getMaxArguments());
  }

  @Test(timeout = 4000)
  public void test33()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      compiler0.initCompilerOptionsIfTesting();
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      JSTypeNative jSTypeNative0 = JSTypeNative.ERROR_FUNCTION_TYPE;
      FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
      FunctionType functionType1 = jSTypeRegistry0.createFunctionTypeWithNewReturnType(functionType0, functionType0);
      // Undeclared exception!
      try { 
        typeValidator0.expectCanOverride((NodeTraversal) null, (Node) null, functionType1, functionType0, "Not declared as a constructor", functionType0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeValidator", e);
      }
  }

  @Test(timeout = 4000)
  public void test34()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("+^aO:}`|#3#k=@{`}", "+^aO:}`|#3#k=@{`}");
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      JSTypeNative jSTypeNative0 = JSTypeNative.LEAST_FUNCTION_TYPE;
      FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
      DeadAssignmentsElimination deadAssignmentsElimination0 = new DeadAssignmentsElimination(compiler0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, deadAssignmentsElimination0, (ScopeCreator) null);
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      // Undeclared exception!
      try { 
        typeValidator0.expectSuperType(nodeTraversal0, node0, functionType0, functionType0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeValidator", e);
      }
  }

  @Test(timeout = 4000)
  public void test35()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      compiler0.initCompilerOptionsIfTesting();
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      JSTypeNative jSTypeNative0 = JSTypeNative.FUNCTION_INSTANCE_TYPE;
      FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
      CheckRegExp checkRegExp0 = new CheckRegExp(compiler0);
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkRegExp0, typedScopeCreator0);
      typeValidator0.expectSuperType(nodeTraversal0, (Node) null, functionType0, functionType0);
      assertEquals(1, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test36()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode(", ", ", ");
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      JSTypeNative jSTypeNative0 = JSTypeNative.NO_RESOLVED_TYPE;
      FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
      typeValidator0.expectCanCast((NodeTraversal) null, node0, functionType0, functionType0);
      assertFalse(functionType0.isNoObjectType());
  }

  @Test(timeout = 4000)
  public void test37()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode(", ", ", ");
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      JSTypeNative jSTypeNative0 = JSTypeNative.FUNCTION_INSTANCE_TYPE;
      FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
      JSTypeNative jSTypeNative1 = JSTypeNative.NUMBER_STRING_BOOLEAN;
      JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[1];
      jSTypeNativeArray0[0] = jSTypeNative1;
      JSType jSType0 = jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
      // Undeclared exception!
      try { 
        typeValidator0.expectCanCast((NodeTraversal) null, node0, jSType0, functionType0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeValidator", e);
      }
  }

  @Test(timeout = 4000)
  public void test38()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      compiler0.initCompilerOptionsIfTesting();
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      JSTypeNative jSTypeNative0 = JSTypeNative.ERROR_FUNCTION_TYPE;
      FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
      JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
      NoType noType0 = (NoType)jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
      typeValidator0.expectCanCast((NodeTraversal) null, (Node) null, functionType0, noType0);
      assertTrue(noType0.hasCachedValues());
  }

  @Test(timeout = 4000)
  public void test39()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode(", ", ", ");
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      JSTypeNative jSTypeNative0 = JSTypeNative.ERROR_FUNCTION_TYPE;
      FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
      Scope scope0 = new Scope(node0, functionType0);
      Scope.Var scope_Var0 = scope0.declare("Not declared as a type name", node0, functionType0, (CompilerInput) null, true);
      // Undeclared exception!
      try { 
        typeValidator0.expectUndeclaredVariable("Not declared as a constructor", node0, node0, scope_Var0, "\" is already defined (as something other than a ", functionType0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.common.base.Preconditions", e);
      }
  }

  @Test(timeout = 4000)
  public void test40()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      compiler0.parseSyntheticCode(", ", ", ");
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      JSTypeNative jSTypeNative0 = JSTypeNative.FUNCTION_FUNCTION_TYPE;
      FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
      Node node0 = Node.newString(33, "Blh");
      // Undeclared exception!
      try { 
        typeValidator0.expectUndeclaredVariable("Not declared as a constructor", node0, node0, (Scope.Var) null, "Named type with empty name component", functionType0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeValidator", e);
      }
  }

  @Test(timeout = 4000)
  public void test41()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode(", ", ", ");
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      JSTypeNative jSTypeNative0 = JSTypeNative.ERROR_FUNCTION_TYPE;
      FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
      MakeDeclaredNamesUnique makeDeclaredNamesUnique0 = new MakeDeclaredNamesUnique();
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, makeDeclaredNamesUnique0);
      typeValidator0.expectAllInterfaceProperties(nodeTraversal0, node0, functionType0);
      assertEquals(12, Node.COLUMN_BITS);
  }

  @Test(timeout = 4000)
  public void test42()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      compiler0.initCompilerOptionsIfTesting();
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      JSTypeNative jSTypeNative0 = JSTypeNative.ERROR_FUNCTION_TYPE;
      FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
      FunctionType functionType1 = jSTypeRegistry0.createInterfaceType("Unknown class name", (Node) null);
      // Undeclared exception!
      try { 
        typeValidator0.expectCanOverride((NodeTraversal) null, (Node) null, functionType1, functionType0, "Not declared as a constructor", functionType0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeValidator", e);
      }
  }

  @Test(timeout = 4000)
  public void test43()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode(", ", "only arrays or objects can be accessed");
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      JSTypeNative jSTypeNative0 = JSTypeNative.ERROR_FUNCTION_TYPE;
      FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
      MakeDeclaredNamesUnique makeDeclaredNamesUnique0 = new MakeDeclaredNamesUnique();
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, makeDeclaredNamesUnique0);
      JSType[] jSTypeArray0 = new JSType[4];
      jSTypeArray0[3] = (JSType) functionType0;
      FunctionType functionType1 = jSTypeRegistry0.createConstructorType(jSTypeArray0[3], jSTypeArray0);
      boolean boolean0 = typeValidator0.expectCanAssignToPropertyOf(nodeTraversal0, node0, functionType1, jSTypeArray0[3], node0, "");
      assertTrue(functionType1.hasCachedValues());
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void test44()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode(", ", "only arrays or objects can be accessed");
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      JSTypeNative jSTypeNative0 = JSTypeNative.ERROR_FUNCTION_TYPE;
      FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
      MakeDeclaredNamesUnique makeDeclaredNamesUnique0 = new MakeDeclaredNamesUnique();
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, makeDeclaredNamesUnique0);
      JSType[] jSTypeArray0 = new JSType[4];
      FunctionType functionType1 = jSTypeRegistry0.createConstructorType((JSType) functionType0, jSTypeArray0);
      boolean boolean0 = typeValidator0.expectCanAssignToPropertyOf(nodeTraversal0, node0, functionType0, functionType1, node0, "arguments");
      assertTrue(functionType1.hasCachedValues());
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void test45()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode(", ", ", ");
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      String string0 = typeValidator0.getReadableJSTypeName(node0, false);
      assertNotNull(string0);
  }

  @Test(timeout = 4000)
  public void test46()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode(", ", ", ");
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      JSTypeNative jSTypeNative0 = JSTypeNative.ERROR_FUNCTION_TYPE;
      FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
      JSType jSType0 = jSTypeRegistry0.createDefaultObjectUnion(functionType0);
      JSType[] jSTypeArray0 = new JSType[5];
      jSTypeArray0[0] = (JSType) functionType0;
      jSTypeArray0[1] = (JSType) functionType0;
      jSTypeArray0[2] = jSType0;
      JSType jSType1 = jSTypeRegistry0.getGreatestSubtypeWithProperty(jSTypeArray0[1], "Not declared as a type name");
      jSTypeArray0[3] = jSType1;
      jSTypeArray0[4] = jSType0;
      Node node1 = jSTypeRegistry0.createOptionalParameters(jSTypeArray0);
      // Undeclared exception!
      try { 
        typeValidator0.expectArgumentMatchesParameter((NodeTraversal) null, node0, jSType0, functionType0, node1, 0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeValidator", e);
      }
  }

  @Test(timeout = 4000)
  public void test47()  throws Throwable  {
      TypeValidator.TypeMismatch typeValidator_TypeMismatch0 = new TypeValidator.TypeMismatch((JSType) null, (JSType) null);
      boolean boolean0 = typeValidator_TypeMismatch0.equals((Object) null);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void test48()  throws Throwable  {
      TypeValidator.TypeMismatch typeValidator_TypeMismatch0 = new TypeValidator.TypeMismatch((JSType) null, (JSType) null);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
      Vector<JSType> vector0 = new Vector<JSType>();
      FunctionType functionType0 = jSTypeRegistry0.createFunctionType((JSType) null, (List<JSType>) vector0);
      TypeValidator.TypeMismatch typeValidator_TypeMismatch1 = new TypeValidator.TypeMismatch(functionType0, (JSType) null);
      // Undeclared exception!
      try { 
        typeValidator_TypeMismatch0.equals(typeValidator_TypeMismatch1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeValidator$TypeMismatch", e);
      }
  }
}
