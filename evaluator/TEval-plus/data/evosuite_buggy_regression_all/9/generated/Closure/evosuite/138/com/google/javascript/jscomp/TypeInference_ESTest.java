/*
 * This file was automatically generated by EvoSuite
 * Wed Jul 12 05:08:47 GMT 2023
 */

package com.google.javascript.jscomp;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import com.google.common.collect.Multimap;
import com.google.javascript.jscomp.ClosureCodingConvention;
import com.google.javascript.jscomp.ClosureReverseAbstractInterpreter;
import com.google.javascript.jscomp.Compiler;
import com.google.javascript.jscomp.CompilerInput;
import com.google.javascript.jscomp.ControlFlowGraph;
import com.google.javascript.jscomp.DefaultCodingConvention;
import com.google.javascript.jscomp.FlowScope;
import com.google.javascript.jscomp.GoogleCodingConvention;
import com.google.javascript.jscomp.JSSourceFile;
import com.google.javascript.jscomp.LinkedFlowScope;
import com.google.javascript.jscomp.ReverseAbstractInterpreter;
import com.google.javascript.jscomp.Scope;
import com.google.javascript.jscomp.SemanticReverseAbstractInterpreter;
import com.google.javascript.jscomp.TypeInference;
import com.google.javascript.jscomp.TypedScopeCreator;
import com.google.javascript.rhino.ErrorReporter;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.SimpleErrorReporter;
import com.google.javascript.rhino.jstype.BooleanLiteralSet;
import com.google.javascript.rhino.jstype.FunctionType;
import com.google.javascript.rhino.jstype.JSType;
import com.google.javascript.rhino.jstype.JSTypeRegistry;
import java.io.PipedOutputStream;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.List;
import java.util.PriorityQueue;
import java.util.SortedSet;
import java.util.Stack;
import java.util.TreeSet;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.mock.java.io.MockPrintStream;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class TypeInference_ESTest extends TypeInference_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void test00()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newNumber(3131.517433571686);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      Scope scope0 = new Scope(node0, compiler0);
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(defaultCodingConvention0, (JSTypeRegistry) null);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      assertNotNull(flowScope0);
  }

  @Test(timeout = 4000)
  public void test01()  throws Throwable  {
      PipedOutputStream pipedOutputStream0 = new PipedOutputStream();
      MockPrintStream mockPrintStream0 = new MockPrintStream(pipedOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = new Node(0, 0, 0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node0, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
      Multimap<Scope, Scope.Var> multimap0 = typeInference0.getAssignedOuterLocalVars();
      assertNotNull(multimap0);
  }

  @Test(timeout = 4000)
  public void test02()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = new Node((-136), (-136), (-136));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      Scope scope0 = new Scope(node0, compiler0);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      PriorityQueue<Scope.Var> priorityQueue0 = new PriorityQueue<Scope.Var>((SortedSet<? extends Scope.Var>) treeSet0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, priorityQueue0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(33, node0);
      // Undeclared exception!
      try { 
        typeInference0.flowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // -136
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test03()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = new Node(120, 57, 57);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node0, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.flowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test04()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = new Node(0, 0, 0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
      Scope scope0 = new Scope(node0, compiler0);
      JSType jSType0 = jSTypeRegistry0.createRecordTypeFromNodes(node0, "C!3Ez/Y", scope0);
      JSType[] jSTypeArray0 = new JSType[1];
      FunctionType functionType0 = jSTypeRegistry0.createConstructorType(jSType0, jSTypeArray0);
      JSSourceFile jSSourceFile0 = JSSourceFile.fromCode("Unknown class name", "{");
      CompilerInput compilerInput0 = new CompilerInput(jSSourceFile0);
      scope0.declare("JSCompiler_ObjectPropertyString", node0, functionType0, compilerInput0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      PriorityQueue<Scope.Var> priorityQueue0 = new PriorityQueue<Scope.Var>();
      Node node1 = new Node(129, node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, priorityQueue0);
  }

  @Test(timeout = 4000)
  public void test05()  throws Throwable  {
      Compiler compiler0 = new Compiler((PrintStream) null);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope((Node) null, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0);
      FlowScope flowScope0 = typeInference0.createInitialEstimateLattice();
      List<FlowScope> list0 = typeInference0.branchedFlowThrough((Node) null, flowScope0);
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void test06()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = new Node((-136), (-136), (-136));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node0, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.SYN_BLOCK;
      controlFlowGraph0.connectToImplicitReturn(node0, controlFlowGraph_Branch0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
      assertFalse(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void test07()  throws Throwable  {
      PipedOutputStream pipedOutputStream0 = new PipedOutputStream();
      MockPrintStream mockPrintStream0 = new MockPrintStream(pipedOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = new Node(0, 0, 0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node0, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_TRUE;
      controlFlowGraph0.connectToImplicitReturn(node0, controlFlowGraph_Branch0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // EOF 0 does not have a condition.
         //
         verifyException("com.google.javascript.jscomp.NodeUtil", e);
      }
  }

  @Test(timeout = 4000)
  public void test08()  throws Throwable  {
      PipedOutputStream pipedOutputStream0 = new PipedOutputStream();
      MockPrintStream mockPrintStream0 = new MockPrintStream(pipedOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = new Node(0, 0, 105);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node0, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(4, node0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test09()  throws Throwable  {
      PipedOutputStream pipedOutputStream0 = new PipedOutputStream();
      MockPrintStream mockPrintStream0 = new MockPrintStream(pipedOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = new Node(0, 0, 0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
      Scope scope0 = new Scope(node0, compiler0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      PriorityQueue<Scope.Var> priorityQueue0 = new PriorityQueue<Scope.Var>((SortedSet<? extends Scope.Var>) treeSet0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, priorityQueue0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(5, node0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test10()  throws Throwable  {
      PipedOutputStream pipedOutputStream0 = new PipedOutputStream();
      MockPrintStream mockPrintStream0 = new MockPrintStream(pipedOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = new Node(0, 0, 0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node0, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(8);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // SETNAME does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test11()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = new Node(57, 57, 57);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node0, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(9, node0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test12()  throws Throwable  {
      PipedOutputStream pipedOutputStream0 = new PipedOutputStream();
      MockPrintStream mockPrintStream0 = new MockPrintStream(pipedOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = new Node((-2901), (-2901), 126);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node0, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(10, 49, 120);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test13()  throws Throwable  {
      PipedOutputStream pipedOutputStream0 = new PipedOutputStream();
      MockPrintStream mockPrintStream0 = new MockPrintStream(pipedOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = new Node(14, 86, 2732);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node0, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(11, node0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test14()  throws Throwable  {
      PipedOutputStream pipedOutputStream0 = new PipedOutputStream();
      MockPrintStream mockPrintStream0 = new MockPrintStream(pipedOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = new Node(0, 0, 0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      Node node1 = new Node(12, 10, 47);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node1, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test15()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = new Node(57, 57, 57);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node0, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(13, node0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test16()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = new Node(0, 0, 0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node0, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(15, node0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test17()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = new Node(0, 0, 0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node0, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
      Node node1 = new Node(16, node0, node0, node0, 114, 9);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test18()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = new Node(1184, (-136), 2022);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      Scope scope0 = new Scope(node0, compiler0);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeSet0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(17, (-30), 4);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test19()  throws Throwable  {
      PipedOutputStream pipedOutputStream0 = new PipedOutputStream();
      MockPrintStream mockPrintStream0 = new MockPrintStream(pipedOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = new Node(0, 0, 0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node0, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
      Node node1 = new Node(18, node0, node0, 5, 8367);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test20()  throws Throwable  {
      PipedOutputStream pipedOutputStream0 = new PipedOutputStream();
      MockPrintStream mockPrintStream0 = new MockPrintStream(pipedOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = new Node(0, 0, 0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node0, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(19, node0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test21()  throws Throwable  {
      PipedOutputStream pipedOutputStream0 = new PipedOutputStream();
      MockPrintStream mockPrintStream0 = new MockPrintStream(pipedOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = new Node(0, 0, 0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node0, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(21, node0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test22()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = new Node(0, 0, 0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node0, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(22, node0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // SUB : com.google.javascript.rhino.jstype.NumberType@0000000041 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test23()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newNumber(2368.2072961);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node0, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(23, node0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test24()  throws Throwable  {
      PipedOutputStream pipedOutputStream0 = new PipedOutputStream();
      MockPrintStream mockPrintStream0 = new MockPrintStream(pipedOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = new Node(25, 25, 25);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node0, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node0, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test25()  throws Throwable  {
      PipedOutputStream pipedOutputStream0 = new PipedOutputStream();
      MockPrintStream mockPrintStream0 = new MockPrintStream(pipedOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = new Node(0, 0, 0);
      Node node1 = new Node(27, 88, 3969);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node1, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test26()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = new Node(0, 0, 0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node0, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(28, node0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test27()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = new Node(111, 111, 111);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
      Scope scope0 = new Scope(node0, compiler0);
      GoogleCodingConvention googleCodingConvention0 = (GoogleCodingConvention)compiler0.defaultCodingConvention;
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      PriorityQueue<Scope.Var> priorityQueue0 = new PriorityQueue<Scope.Var>((SortedSet<? extends Scope.Var>) treeSet0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, priorityQueue0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(29, node0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test28()  throws Throwable  {
      PipedOutputStream pipedOutputStream0 = new PipedOutputStream();
      MockPrintStream mockPrintStream0 = new MockPrintStream(pipedOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = new Node(0, 0, 0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node0, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(30, node0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // NEW does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test29()  throws Throwable  {
      PipedOutputStream pipedOutputStream0 = new PipedOutputStream();
      MockPrintStream mockPrintStream0 = new MockPrintStream(pipedOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = new Node(0, 0, 0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node0, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(31, node0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // DELPROP does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test30()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = new Node(0, 0, 0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node0, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(34, node0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // SETPROP does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test31()  throws Throwable  {
      PipedOutputStream pipedOutputStream0 = new PipedOutputStream();
      MockPrintStream mockPrintStream0 = new MockPrintStream(pipedOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = new Node(0, 0, 0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node0, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(35, node0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // GETELEM does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test32()  throws Throwable  {
      PipedOutputStream pipedOutputStream0 = new PipedOutputStream();
      MockPrintStream mockPrintStream0 = new MockPrintStream(pipedOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = new Node(0, 0, 0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node0, compiler0);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, treeSet0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(36, node0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test33()  throws Throwable  {
      PipedOutputStream pipedOutputStream0 = new PipedOutputStream();
      MockPrintStream mockPrintStream0 = new MockPrintStream(pipedOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = new Node(0, 0, 0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
      Scope scope0 = new Scope(node0, compiler0);
      GoogleCodingConvention googleCodingConvention0 = (GoogleCodingConvention)compiler0.defaultCodingConvention;
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, treeSet0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(37, node0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test34()  throws Throwable  {
      PipedOutputStream pipedOutputStream0 = new PipedOutputStream();
      MockPrintStream mockPrintStream0 = new MockPrintStream(pipedOutputStream0);
      Node node0 = new Node(0, 0, 0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node0, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(38, node0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: UnsupportedOperationException");
      
      } catch(UnsupportedOperationException e) {
         //
         // NAME is not a string node
         //
         verifyException("com.google.javascript.rhino.Node", e);
      }
  }

  @Test(timeout = 4000)
  public void test35()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = new Node(120, 57, 57);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node0, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = Node.newString(";\u0005Sdp]#H=T}");
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test36()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = new Node(120, 57, 57);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node0, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(42, node0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test37()  throws Throwable  {
      PipedOutputStream pipedOutputStream0 = new PipedOutputStream();
      MockPrintStream mockPrintStream0 = new MockPrintStream(pipedOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = new Node(0, 0, 0);
      Node node1 = new Node(43, 23, 401);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      Scope scope0 = new Scope(node1, compiler0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, treeSet0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // FALSE 23 : com.google.javascript.rhino.jstype.BooleanType@0000000039 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test38()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = new Node(0, 0, 0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node0, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(44, node0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test39()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = new Node((-1605), 926, (-557));
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      Scope scope0 = new Scope(node0, compiler0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(45, node0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test40()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = new Node(0, 0, 0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node0, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(46, node0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // SHNE : com.google.javascript.rhino.jstype.BooleanType@0000000039 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test41()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = new Node(114, 0, 114);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node0, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(47, node0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // OBJECT : com.google.javascript.rhino.jstype.InstanceObjectType@0000000206 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test42()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = new Node(0, 0, 0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
      Scope scope0 = new Scope(node0, compiler0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(48, node0);
      ArrayList<Scope.Var> arrayList0 = new ArrayList<Scope.Var>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, arrayList0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test43()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = new Node(76, 76, 76);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node0, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(49, node0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test44()  throws Throwable  {
      PipedOutputStream pipedOutputStream0 = new PipedOutputStream();
      MockPrintStream mockPrintStream0 = new MockPrintStream(pipedOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = new Node(0, 0, 0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node0, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(53, node0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test45()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newNumber(3131.517433571686);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      Scope scope0 = new Scope(node0, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(64, node0);
      // Undeclared exception!
      try { 
        typeInference0.flowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test46()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = new Node((-136), (-136), (-136));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
      Scope scope0 = new Scope(node0, compiler0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      PriorityQueue<Scope.Var> priorityQueue0 = new PriorityQueue<Scope.Var>((SortedSet<? extends Scope.Var>) treeSet0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, priorityQueue0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(71, node0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test47()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = new Node(0, 0, 0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      Stack<JSType> stack0 = new Stack<JSType>();
      Node node1 = jSTypeRegistry0.createParameters((List<JSType>) stack0);
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node0, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test48()  throws Throwable  {
      PipedOutputStream pipedOutputStream0 = new PipedOutputStream();
      MockPrintStream mockPrintStream0 = new MockPrintStream(pipedOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = new Node(0, 0, 0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node0, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
      Node node1 = new Node(85, node0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test49()  throws Throwable  {
      PipedOutputStream pipedOutputStream0 = new PipedOutputStream();
      MockPrintStream mockPrintStream0 = new MockPrintStream(pipedOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = new Node(0, 0, 0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node0, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(87, node0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test50()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = new Node(0, 0, 0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node0, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(91, node0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test51()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = new Node((-2640), 124, 124);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node0, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(93, node0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test52()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = new Node((-136), (-136), (-136));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
      Scope scope0 = new Scope(node0, compiler0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      PriorityQueue<Scope.Var> priorityQueue0 = new PriorityQueue<Scope.Var>((SortedSet<? extends Scope.Var>) treeSet0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, priorityQueue0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(99, node0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test53()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = new Node(57, 57, 57);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node0, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(102, node0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test54()  throws Throwable  {
      PipedOutputStream pipedOutputStream0 = new PipedOutputStream();
      MockPrintStream mockPrintStream0 = new MockPrintStream(pipedOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = new Node(0, 0, 0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node0, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(103, node0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test55()  throws Throwable  {
      PipedOutputStream pipedOutputStream0 = new PipedOutputStream();
      MockPrintStream mockPrintStream0 = new MockPrintStream(pipedOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = new Node(20, 20, 20);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(104, node0);
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // DOT does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test56()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = new Node(0, 0, 0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node0, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(105, node0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test57()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = new Node((-136), (-136), (-136));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node0, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(113, node0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // WHILE does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test58()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = new Node(114, 0, 114);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node0, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node0, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test59()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = new Node(0, 0, 0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node0, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(115, node0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test60()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = new Node(0, 0, 0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node0, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(116, node0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // BREAK does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test61()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = new Node(57, 57, 57);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node0, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(117, node0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // CONTINUE does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test62()  throws Throwable  {
      PipedOutputStream pipedOutputStream0 = new PipedOutputStream();
      MockPrintStream mockPrintStream0 = new MockPrintStream(pipedOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = new Node(0, 0, 0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node0, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(123, node0, (-9), 278);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // RESERVED does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test63()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = new Node(0, 0, 0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node0, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = compiler0.parseSyntheticCode("V'yA[aFF=14l0", "V'yA[aFF=14l0");
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test64()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = new Node(57, 57, 57);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node0, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(126, node0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // LABEL does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test65()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = new Node(0, 0, 0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node0, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(129, node0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test66()  throws Throwable  {
      PipedOutputStream pipedOutputStream0 = new PipedOutputStream();
      MockPrintStream mockPrintStream0 = new MockPrintStream(pipedOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = new Node(0, 0, 0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      Scope scope0 = new Scope(node0, compiler0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      PriorityQueue<Scope.Var> priorityQueue0 = new PriorityQueue<Scope.Var>((SortedSet<? extends Scope.Var>) treeSet0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, priorityQueue0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(130, node0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // EXPR_RESULT does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test67()  throws Throwable  {
      PipedOutputStream pipedOutputStream0 = new PipedOutputStream();
      MockPrintStream mockPrintStream0 = new MockPrintStream(pipedOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = new Node(0, 0, 0);
      Node node1 = new Node(26, (-248), 1908);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      Scope scope0 = new Scope(node1, compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node2 = new Node(30, node1);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node2, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // NEW does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test68()  throws Throwable  {
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.FALSE;
      BooleanLiteralSet booleanLiteralSet1 = TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet0, true);
      assertSame(booleanLiteralSet1, booleanLiteralSet0);
  }

  @Test(timeout = 4000)
  public void test69()  throws Throwable  {
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.TRUE;
      BooleanLiteralSet booleanLiteralSet1 = TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet0, false);
      assertEquals(BooleanLiteralSet.TRUE, booleanLiteralSet1);
  }
}
