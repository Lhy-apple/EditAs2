/*
 * This file was automatically generated by EvoSuite
 * Wed Jul 12 04:54:47 GMT 2023
 */

package com.google.javascript.jscomp;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import com.google.javascript.jscomp.CheckAccidentalSemicolon;
import com.google.javascript.jscomp.CheckLevel;
import com.google.javascript.jscomp.CheckRegExp;
import com.google.javascript.jscomp.CheckUnreachableCode;
import com.google.javascript.jscomp.ClosureCodingConvention;
import com.google.javascript.jscomp.ClosureReverseAbstractInterpreter;
import com.google.javascript.jscomp.Compiler;
import com.google.javascript.jscomp.CompilerOptions;
import com.google.javascript.jscomp.CrossModuleCodeMotion;
import com.google.javascript.jscomp.DefaultPassConfig;
import com.google.javascript.jscomp.GoogleCodingConvention;
import com.google.javascript.jscomp.JSModule;
import com.google.javascript.jscomp.JSModuleGraph;
import com.google.javascript.jscomp.JSSourceFile;
import com.google.javascript.jscomp.MemoizedScopeCreator;
import com.google.javascript.jscomp.NodeTraversal;
import com.google.javascript.jscomp.ReverseAbstractInterpreter;
import com.google.javascript.jscomp.Scope;
import com.google.javascript.jscomp.ScopeCreator;
import com.google.javascript.jscomp.SemanticReverseAbstractInterpreter;
import com.google.javascript.jscomp.SyntacticScopeCreator;
import com.google.javascript.jscomp.TypeCheck;
import com.google.javascript.jscomp.TypedScopeCreator;
import com.google.javascript.jscomp.UnfoldCompoundAssignments;
import com.google.javascript.jscomp.VarCheck;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.SimpleErrorReporter;
import com.google.javascript.rhino.jstype.JSType;
import com.google.javascript.rhino.jstype.JSTypeRegistry;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.PriorityQueue;
import java.util.Stack;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class TypeCheck_ESTest extends TypeCheck_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void test000()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      MemoizedScopeCreator memoizedScopeCreator0 = new MemoizedScopeCreator((ScopeCreator) null);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, memoizedScopeCreator0);
      Node node0 = new Node(35, 35, 52);
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node0, node0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeCheck", e);
      }
  }

  @Test(timeout = 4000)
  public void test001()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      Node node0 = new Node(2071, 3064, (-938));
      Node node1 = new Node(9, node0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertEquals(0, compiler0.getWarningCount());
      assertEquals(0, compiler0.getErrorCount());
  }

  @Test(timeout = 4000)
  public void test002()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node0 = new Node(84, 84, 84);
      Node node1 = new Node(12, node0, 30, 56);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(0, compiler0.getErrorCount());
      assertFalse(compiler0.hasErrors());
  }

  @Test(timeout = 4000)
  public void test003()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      Node node0 = Node.newString("");
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0, scope0, typedScopeCreator0, compilerOptions0.checkGlobalThisLevel, compilerOptions0.checkMissingReturn);
      // Undeclared exception!
      try { 
        typeCheck0.process(node0, node0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.common.base.Preconditions", e);
      }
  }

  @Test(timeout = 4000)
  public void test004()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node0 = Node.newString("");
      Node node1 = new Node(31, node0);
      typeCheck0.processForTesting((Node) null, node0);
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test005()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node0 = new Node(100, 21, 21);
      Node node1 = new Node(131, node0);
      Node node2 = new Node(622, node1, 16, (-2058));
      typeCheck0.processForTesting(node0, node0);
      // Undeclared exception!
      try { 
        typeCheck0.process(node0, node1);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.common.base.Preconditions", e);
      }
  }

  @Test(timeout = 4000)
  public void test006()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node0 = new Node(106, 106, (-938));
      Node node1 = new Node(3, node0);
      typeCheck0.processForTesting(node0, node0);
      // Undeclared exception!
      try { 
        typeCheck0.processForTesting(node1, node1);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.common.base.Preconditions", e);
      }
  }

  @Test(timeout = 4000)
  public void test007()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      Node node0 = new Node(2969, 2969, 2969);
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0, scope0, (ScopeCreator) null, compilerOptions0.checkRequires, compilerOptions0.reportUnknownTypes);
      // Undeclared exception!
      try { 
        typeCheck0.processForTesting(node0, node0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.common.base.Preconditions", e);
      }
  }

  @Test(timeout = 4000)
  public void test008()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      DefaultPassConfig defaultPassConfig0 = new DefaultPassConfig(compilerOptions0);
      TypeCheck typeCheck0 = defaultPassConfig0.makeTypeCheck(compiler0);
      Node node0 = new Node(34, 34, 409);
      // Undeclared exception!
      try { 
        typeCheck0.processForTesting(node0, node0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.common.base.Preconditions", e);
      }
  }

  @Test(timeout = 4000)
  public void test009()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Stack<JSSourceFile> stack0 = new Stack<JSSourceFile>();
      compiler0.compile((List<JSSourceFile>) stack0, (List<JSSourceFile>) stack0, compilerOptions0);
      DefaultPassConfig defaultPassConfig0 = new DefaultPassConfig(compilerOptions0);
      Node node0 = new Node(1536, 37, 120);
      Node node1 = new Node(86, node0, (-2961), 27);
      TypeCheck typeCheck0 = defaultPassConfig0.makeTypeCheck(compiler0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertEquals(1, Node.SPECIALCALL_EVAL);
  }

  @Test(timeout = 4000)
  public void test010()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      CheckAccidentalSemicolon checkAccidentalSemicolon0 = new CheckAccidentalSemicolon(compilerOptions0.checkMissingGetCssNameLevel);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkAccidentalSemicolon0);
      DefaultPassConfig defaultPassConfig0 = new DefaultPassConfig(compilerOptions0);
      TypeCheck typeCheck0 = defaultPassConfig0.makeTypeCheck(compiler0);
      Node node0 = new Node(118, 118, 70);
      typeCheck0.visit(nodeTraversal0, node0, node0);
      assertEquals(36, Node.QUOTED_PROP);
  }

  @Test(timeout = 4000)
  public void test011()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
      Node node0 = compiler0.getNodeForCodeInsertion((JSModule) null);
      typeCheck0.visit(nodeTraversal0, node0, (Node) null);
      assertEquals(34, Node.NAME_PROP);
  }

  @Test(timeout = 4000)
  public void test012()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
      Node node0 = compiler0.parseInputs();
      node0.addSuppression((String) null);
      typeCheck0.visit(nodeTraversal0, node0, node0);
      assertEquals(18, Node.SPECIAL_PROP_PROP);
  }

  @Test(timeout = 4000)
  public void test013()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
      LinkedList<JSType> linkedList1 = new LinkedList<JSType>();
      Node node0 = jSTypeRegistry0.createParameters((List<JSType>) linkedList1);
      Node node1 = new Node(4, node0);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertEquals(46, Node.IS_NAMESPACE);
  }

  @Test(timeout = 4000)
  public void test014()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
      Node node0 = Node.newString("3{ +k]Ezq'yZCM }");
      Node node1 = new Node(5, node0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertTrue(compiler0.hasErrors());
      assertEquals(1, compiler0.getErrorCount());
  }

  @Test(timeout = 4000)
  public void test015()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
      Node node0 = Node.newString("");
      Node node1 = new Node(6, node0);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertTrue(compiler0.hasErrors());
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test016()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      CheckAccidentalSemicolon checkAccidentalSemicolon0 = new CheckAccidentalSemicolon(compilerOptions0.reportMissingOverride);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkAccidentalSemicolon0);
      DefaultPassConfig defaultPassConfig0 = new DefaultPassConfig(compilerOptions0);
      TypeCheck typeCheck0 = defaultPassConfig0.makeTypeCheck(compiler0);
      LinkedList<JSType> linkedList1 = new LinkedList<JSType>();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      Node node0 = jSTypeRegistry0.createParameters((List<JSType>) linkedList1);
      Node node1 = new Node(7, node0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(1, compiler0.getErrorCount());
      assertTrue(compiler0.hasErrors());
  }

  @Test(timeout = 4000)
  public void test017()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
      Node node0 = new Node(8, 138, 255);
      Node node1 = new Node(10, node0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertFalse(compiler0.hasErrors());
      assertEquals(0, compiler0.getWarningCount());
      assertEquals(0, compiler0.getErrorCount());
  }

  @Test(timeout = 4000)
  public void test018()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
      Node node0 = Node.newString("3{ +k]Ezq'yZCM }");
      Node node1 = new Node(11, node0);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertEquals(0, compiler0.getWarningCount());
      assertEquals(0, compiler0.getErrorCount());
      assertFalse(compiler0.hasErrors());
  }

  @Test(timeout = 4000)
  public void test019()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Stack<JSSourceFile> stack0 = new Stack<JSSourceFile>();
      compiler0.compile((List<JSSourceFile>) stack0, (List<JSSourceFile>) stack0, compilerOptions0);
      DefaultPassConfig defaultPassConfig0 = new DefaultPassConfig(compilerOptions0);
      TypeCheck typeCheck0 = defaultPassConfig0.makeTypeCheck(compiler0);
      Node node0 = new Node(13, 57, 11);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, (NodeTraversal.Callback) null);
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node0, (Node) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeCheck", e);
      }
  }

  @Test(timeout = 4000)
  public void test020()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
      Node node0 = new Node(14, 37, 37);
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node0, node0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeCheck", e);
      }
  }

  @Test(timeout = 4000)
  public void test021()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      Node node0 = new Node(106, 37, (-2987));
      Node node1 = new Node(15, node0, 146, 35);
      DefaultPassConfig defaultPassConfig0 = new DefaultPassConfig(compilerOptions0);
      TypeCheck typeCheck0 = defaultPassConfig0.makeTypeCheck(compiler0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(26, Node.DIRECTCALL_PROP);
  }

  @Test(timeout = 4000)
  public void test022()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Stack<JSSourceFile> stack0 = new Stack<JSSourceFile>();
      compiler0.compile((List<JSSourceFile>) stack0, (List<JSSourceFile>) stack0, compilerOptions0);
      DefaultPassConfig defaultPassConfig0 = new DefaultPassConfig(compilerOptions0);
      Node node0 = new Node(62, 62, 62);
      Node node1 = new Node(16, node0, 31, 2);
      TypeCheck typeCheck0 = defaultPassConfig0.makeTypeCheck(compiler0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(20, Node.FINALLY_PROP);
  }

  @Test(timeout = 4000)
  public void test023()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      CheckAccidentalSemicolon checkAccidentalSemicolon0 = new CheckAccidentalSemicolon(compilerOptions0.checkMissingGetCssNameLevel);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkAccidentalSemicolon0);
      DefaultPassConfig defaultPassConfig0 = new DefaultPassConfig(compilerOptions0);
      TypeCheck typeCheck0 = defaultPassConfig0.makeTypeCheck(compiler0);
      Node node0 = new Node(17, 17, 265);
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node0, node0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeCheck", e);
      }
  }

  @Test(timeout = 4000)
  public void test024()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
      Node node0 = new Node((-1501), 149, 149);
      Node node1 = new Node(18, node0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(0, compiler0.getErrorCount());
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test025()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      CheckAccidentalSemicolon checkAccidentalSemicolon0 = new CheckAccidentalSemicolon(compilerOptions0.checkUndefinedProperties);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkAccidentalSemicolon0);
      DefaultPassConfig defaultPassConfig0 = new DefaultPassConfig(compilerOptions0);
      TypeCheck typeCheck0 = defaultPassConfig0.makeTypeCheck(compiler0);
      Node node0 = new Node(21, 21, (-1713));
      Node node1 = new Node(19, node0);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertEquals(0, compiler0.getWarningCount());
      assertEquals(0, compiler0.getErrorCount());
  }

  @Test(timeout = 4000)
  public void test026()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      VarCheck varCheck0 = new VarCheck(compiler0, false);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, varCheck0, (ScopeCreator) null);
      Node node0 = new Node(105, 105, 105);
      Node node1 = new Node(20, node0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(0, compiler0.getWarningCount());
      assertEquals(0, compiler0.getErrorCount());
  }

  @Test(timeout = 4000)
  public void test027()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
      Node node0 = new Node((-1501), (-1501), 120);
      Node node1 = new Node(21, node0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertFalse(compiler0.hasErrors());
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test028()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node0 = Node.newString("");
      Node node1 = new Node(22, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertEquals(0, compiler0.getWarningCount());
      assertFalse(compiler0.hasErrors());
      assertEquals(0, compiler0.getErrorCount());
  }

  @Test(timeout = 4000)
  public void test029()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
      Node node0 = Node.newString("");
      Node node1 = new Node(23, node0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(0, compiler0.getWarningCount());
      assertFalse(compiler0.hasErrors());
  }

  @Test(timeout = 4000)
  public void test030()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
      JSType[] jSTypeArray0 = new JSType[0];
      Node node0 = jSTypeRegistry0.createParametersWithVarArgs(jSTypeArray0);
      Node node1 = new Node(24, node0, node0, node0, node0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(0, compiler0.getWarningCount());
      assertEquals(0, compiler0.getErrorCount());
      assertFalse(compiler0.hasErrors());
  }

  @Test(timeout = 4000)
  public void test031()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
      Node node0 = new Node(1831, 1431655764, 119);
      Node node1 = new Node(25, node0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertFalse(compiler0.hasErrors());
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test032()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
      MemoizedScopeCreator memoizedScopeCreator0 = new MemoizedScopeCreator(typedScopeCreator0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, memoizedScopeCreator0);
      Node node0 = new Node(55, 55, (-1497));
      Node node1 = new Node(26, 1, 11);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(23, Node.VARIABLE_PROP);
  }

  @Test(timeout = 4000)
  public void test033()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
      Node node0 = new Node(1831, 144, 1831);
      Node node1 = new Node(27, node0);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertTrue(node1.hasOneChild());
  }

  @Test(timeout = 4000)
  public void test034()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      CheckAccidentalSemicolon checkAccidentalSemicolon0 = new CheckAccidentalSemicolon(compilerOptions0.reportMissingOverride);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkAccidentalSemicolon0);
      DefaultPassConfig defaultPassConfig0 = new DefaultPassConfig(compilerOptions0);
      TypeCheck typeCheck0 = defaultPassConfig0.makeTypeCheck(compiler0);
      Node node0 = new Node(28, 28, 101);
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node0, node0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeCheck", e);
      }
  }

  @Test(timeout = 4000)
  public void test035()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      CheckAccidentalSemicolon checkAccidentalSemicolon0 = new CheckAccidentalSemicolon(compilerOptions0.reportUnknownTypes);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkAccidentalSemicolon0);
      DefaultPassConfig defaultPassConfig0 = new DefaultPassConfig(compilerOptions0);
      TypeCheck typeCheck0 = defaultPassConfig0.makeTypeCheck(compiler0);
      Node node0 = new Node(104, 150, 150);
      Node node1 = new Node(29, node0);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertEquals(2, Node.BREAK_PROP);
  }

  @Test(timeout = 4000)
  public void test036()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      CheckAccidentalSemicolon checkAccidentalSemicolon0 = new CheckAccidentalSemicolon(compilerOptions0.checkRequires);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkAccidentalSemicolon0);
      DefaultPassConfig defaultPassConfig0 = new DefaultPassConfig(compilerOptions0);
      TypeCheck typeCheck0 = defaultPassConfig0.makeTypeCheck(compiler0);
      Node node0 = new Node((-1), 34, (-1));
      Node node1 = new Node(30, node0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test037()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      CheckAccidentalSemicolon checkAccidentalSemicolon0 = new CheckAccidentalSemicolon(compilerOptions0.checkMethods);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkAccidentalSemicolon0);
      DefaultPassConfig defaultPassConfig0 = new DefaultPassConfig(compilerOptions0);
      TypeCheck typeCheck0 = defaultPassConfig0.makeTypeCheck(compiler0);
      Node node0 = new Node(133, 4420, 170);
      Node node1 = new Node(31, node0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(1, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test038()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node0 = Node.newString("5");
      Node node1 = new Node(33, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node1, node1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeCheck", e);
      }
  }

  @Test(timeout = 4000)
  public void test039()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
      Node node0 = new Node(128, 128, 128);
      Node node1 = new Node(36, node0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertTrue(compiler0.hasErrors());
      assertEquals(1, compiler0.getErrorCount());
  }

  @Test(timeout = 4000)
  public void test040()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      CheckAccidentalSemicolon checkAccidentalSemicolon0 = new CheckAccidentalSemicolon(compilerOptions0.checkGlobalNamesLevel);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkAccidentalSemicolon0);
      DefaultPassConfig defaultPassConfig0 = new DefaultPassConfig(compilerOptions0);
      TypeCheck typeCheck0 = defaultPassConfig0.makeTypeCheck(compiler0);
      Node node0 = new Node(0, 34, 0);
      Node node1 = new Node(37, node0);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test041()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
      Node node0 = new Node(38, 2373, 152);
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node0, node0);
        fail("Expecting exception: UnsupportedOperationException");
      
      } catch(UnsupportedOperationException e) {
         //
         // NAME 2373 is not a string node
         //
         verifyException("com.google.javascript.rhino.Node", e);
      }
  }

  @Test(timeout = 4000)
  public void test042()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
      Node node0 = new Node(39, (-4), 4096);
      typeCheck0.visit(nodeTraversal0, node0, node0);
      assertFalse(node0.isNoSideEffectsCall());
  }

  @Test(timeout = 4000)
  public void test043()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
      Node node0 = Node.newString("");
      Node node1 = new Node(41, node0);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertEquals(0, Node.BOTH);
  }

  @Test(timeout = 4000)
  public void test044()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
      Node node0 = new Node(42, 5, 35);
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node0, node0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeCheck", e);
      }
  }

  @Test(timeout = 4000)
  public void test045()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
      Node node0 = Node.newString("");
      Node node1 = new Node(43, 2, 8292);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(15, Node.CASEARRAY_PROP);
  }

  @Test(timeout = 4000)
  public void test046()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      CheckAccidentalSemicolon checkAccidentalSemicolon0 = new CheckAccidentalSemicolon(compilerOptions0.checkProvides);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkAccidentalSemicolon0);
      DefaultPassConfig defaultPassConfig0 = new DefaultPassConfig(compilerOptions0);
      TypeCheck typeCheck0 = defaultPassConfig0.makeTypeCheck(compiler0);
      Node node0 = new Node((-1), 8, (-1));
      Node node1 = new Node(44, node0, node0, node0);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertEquals(49, Node.DIRECT_EVAL);
  }

  @Test(timeout = 4000)
  public void test047()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
      Node node0 = new Node(45, 124, 105);
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node0, node0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeCheck", e);
      }
  }

  @Test(timeout = 4000)
  public void test048()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
      Node node0 = new Node((-1501), (-1501), (-1501));
      Node node1 = new Node(46, node0);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertEquals(0, node1.getSideEffectFlags());
  }

  @Test(timeout = 4000)
  public void test049()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
      Node node0 = new Node(35, 139, 35);
      Node node1 = new Node(47, node0);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertEquals(7, Node.LOCAL_PROP);
  }

  @Test(timeout = 4000)
  public void test050()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node0 = new Node(8, 8, 8);
      Node node1 = new Node(48, node0);
      Node node2 = new Node(48, node1);
      typeCheck0.processForTesting(node1, node1);
      assertEquals(2, compiler0.getErrorCount());
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test051()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node0 = new Node(37, 765, 125);
      Node node1 = new Node(49, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertEquals(12, Node.COLUMN_BITS);
  }

  @Test(timeout = 4000)
  public void test052()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node0 = new Node(56, 56, 56);
      Node node1 = new Node(50, node0);
      // Undeclared exception!
      try { 
        typeCheck0.visit((NodeTraversal) null, node1, node0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeCheck", e);
      }
  }

  @Test(timeout = 4000)
  public void test053()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
      Node node0 = new Node(51, 115, (-42));
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node0, node0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeCheck", e);
      }
  }

  @Test(timeout = 4000)
  public void test054()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
      Node node0 = new Node(52, 52, 122);
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node0, node0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeCheck", e);
      }
  }

  @Test(timeout = 4000)
  public void test055()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
      MemoizedScopeCreator memoizedScopeCreator0 = new MemoizedScopeCreator(typedScopeCreator0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, memoizedScopeCreator0);
      Node node0 = new Node(55, 55, (-1497));
      typeCheck0.visit(nodeTraversal0, node0, node0);
      assertEquals(1, compiler0.getErrorCount());
      assertTrue(compiler0.hasErrors());
  }

  @Test(timeout = 4000)
  public void test056()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node0 = new Node(56, 56, 56);
      Node node1 = new Node(50, node0);
      typeCheck0.processForTesting(node0, node0);
      assertEquals(1, compiler0.getErrorCount());
      assertTrue(compiler0.hasErrors());
  }

  @Test(timeout = 4000)
  public void test057()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, typedScopeCreator0);
      Node node0 = new Node(59, 59, (-8));
      typeCheck0.visit(nodeTraversal0, node0, node0);
      assertEquals(1, compiler0.getErrorCount());
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test058()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
      Node node0 = Node.newString("");
      Node node1 = new Node(61, node0);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertTrue(compiler0.hasErrors());
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test059()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Stack<JSSourceFile> stack0 = new Stack<JSSourceFile>();
      compiler0.compile((List<JSSourceFile>) stack0, (List<JSSourceFile>) stack0, compilerOptions0);
      DefaultPassConfig defaultPassConfig0 = new DefaultPassConfig(compilerOptions0);
      Node node0 = new Node(62, 62, 62);
      TypeCheck typeCheck0 = defaultPassConfig0.makeTypeCheck(compiler0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node0, node0);
      assertTrue(compiler0.hasErrors());
      assertEquals(1, compiler0.getErrorCount());
  }

  @Test(timeout = 4000)
  public void test060()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
      Node node0 = new Node(63, 63, (-499));
      typeCheck0.visit(nodeTraversal0, node0, node0);
      assertEquals(1, Node.DECR_FLAG);
  }

  @Test(timeout = 4000)
  public void test061()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
      Node node0 = new Node(64, 64, (-847));
      typeCheck0.visit(nodeTraversal0, node0, node0);
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test062()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node0 = new Node(65, 32768, 32768);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node0, node0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeCheck", e);
      }
  }

  @Test(timeout = 4000)
  public void test063()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
      Node node0 = new Node(66, 1, 77);
      typeCheck0.visit(nodeTraversal0, node0, node0);
      boolean boolean0 = typeCheck0.visitName(nodeTraversal0, node0, node0);
      assertEquals(1, compiler0.getErrorCount());
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void test064()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      CheckAccidentalSemicolon checkAccidentalSemicolon0 = new CheckAccidentalSemicolon(compilerOptions0.reportMissingOverride);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkAccidentalSemicolon0);
      DefaultPassConfig defaultPassConfig0 = new DefaultPassConfig(compilerOptions0);
      TypeCheck typeCheck0 = defaultPassConfig0.makeTypeCheck(compiler0);
      Node node0 = new Node(68, 68, 68);
      typeCheck0.visit(nodeTraversal0, node0, node0);
      assertEquals(1, compiler0.getErrorCount());
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test065()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
      Node node0 = new Node(70, 70, (-847));
      typeCheck0.visit(nodeTraversal0, node0, node0);
      assertEquals(1, compiler0.getErrorCount());
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test066()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
      Node node0 = new Node(71, 71, 122);
      typeCheck0.visit(nodeTraversal0, node0, node0);
      assertTrue(compiler0.hasErrors());
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test067()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      CheckAccidentalSemicolon checkAccidentalSemicolon0 = new CheckAccidentalSemicolon(compilerOptions0.reportMissingOverride);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkAccidentalSemicolon0);
      DefaultPassConfig defaultPassConfig0 = new DefaultPassConfig(compilerOptions0);
      TypeCheck typeCheck0 = defaultPassConfig0.makeTypeCheck(compiler0);
      Node node0 = new Node(72, 72, 72);
      typeCheck0.visit(nodeTraversal0, node0, node0);
      assertEquals(1, compiler0.getErrorCount());
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test068()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      CheckAccidentalSemicolon checkAccidentalSemicolon0 = new CheckAccidentalSemicolon(compilerOptions0.checkMethods);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkAccidentalSemicolon0);
      DefaultPassConfig defaultPassConfig0 = new DefaultPassConfig(compilerOptions0);
      TypeCheck typeCheck0 = defaultPassConfig0.makeTypeCheck(compiler0);
      Node node0 = new Node(74, 150, 150);
      typeCheck0.visit(nodeTraversal0, node0, node0);
      assertEquals(1, compiler0.getErrorCount());
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test069()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      CheckAccidentalSemicolon checkAccidentalSemicolon0 = new CheckAccidentalSemicolon(compilerOptions0.checkMissingReturn);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkAccidentalSemicolon0);
      DefaultPassConfig defaultPassConfig0 = new DefaultPassConfig(compilerOptions0);
      TypeCheck typeCheck0 = defaultPassConfig0.makeTypeCheck(compiler0);
      Node node0 = new Node(34, 34, 409);
      Node node1 = new Node(75, node0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(1, compiler0.getErrorCount());
      assertTrue(compiler0.hasErrors());
  }

  @Test(timeout = 4000)
  public void test070()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
      Node node0 = new Node(77, 77, 77);
      typeCheck0.visit(nodeTraversal0, node0, node0);
      assertEquals(0, Node.LABEL_ID_PROP);
  }

  @Test(timeout = 4000)
  public void test071()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
      Node node0 = new Node(79, 79, 1601076620);
      typeCheck0.visit(nodeTraversal0, node0, node0);
      assertEquals(1, compiler0.getErrorCount());
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test072()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
      Node node0 = new Node(128, 128, 128);
      Node node1 = new Node(80, node0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(1, compiler0.getErrorCount());
      assertTrue(compiler0.hasErrors());
  }

  @Test(timeout = 4000)
  public void test073()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      CheckAccidentalSemicolon checkAccidentalSemicolon0 = new CheckAccidentalSemicolon(compilerOptions0.checkMissingReturn);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkAccidentalSemicolon0);
      DefaultPassConfig defaultPassConfig0 = new DefaultPassConfig(compilerOptions0);
      TypeCheck typeCheck0 = defaultPassConfig0.makeTypeCheck(compiler0);
      Node node0 = new Node(82, 104, 0);
      typeCheck0.visit(nodeTraversal0, node0, node0);
      assertTrue(compiler0.hasErrors());
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test074()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
      JSType[] jSTypeArray0 = new JSType[0];
      Node node0 = jSTypeRegistry0.createParametersWithVarArgs(jSTypeArray0);
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node0, node0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeCheck", e);
      }
  }

  @Test(timeout = 4000)
  public void test075()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node0 = new Node(84, 84, 84);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node0, node0);
      assertTrue(compiler0.hasErrors());
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test076()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      CheckAccidentalSemicolon checkAccidentalSemicolon0 = new CheckAccidentalSemicolon(compilerOptions0.checkFunctions);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkAccidentalSemicolon0);
      DefaultPassConfig defaultPassConfig0 = new DefaultPassConfig(compilerOptions0);
      TypeCheck typeCheck0 = defaultPassConfig0.makeTypeCheck(compiler0);
      Node node0 = new Node(34, 34, 409);
      Node node1 = new Node(87, node0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(0, compiler0.getErrorCount());
      assertFalse(compiler0.hasErrors());
  }

  @Test(timeout = 4000)
  public void test077()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
      Node node0 = Node.newString("");
      Node node1 = new Node(88, node0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(0, compiler0.getWarningCount());
      assertFalse(compiler0.hasErrors());
      assertEquals(0, compiler0.getErrorCount());
  }

  @Test(timeout = 4000)
  public void test078()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node0 = new Node(84, 84, 84);
      Node node1 = new Node(90, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(0, compiler0.getWarningCount());
      assertFalse(compiler0.hasErrors());
      assertEquals(0, compiler0.getErrorCount());
  }

  @Test(timeout = 4000)
  public void test079()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node0 = new Node(91, (-769), 91);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node0, node0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeCheck", e);
      }
  }

  @Test(timeout = 4000)
  public void test080()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      ArrayList<JSSourceFile> arrayList0 = new ArrayList<JSSourceFile>();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) arrayList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      CheckRegExp checkRegExp0 = new CheckRegExp(compiler0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkRegExp0, (ScopeCreator) null);
      Node node0 = new Node(92, 2185, 1005);
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node0, node0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeCheck", e);
      }
  }

  @Test(timeout = 4000)
  public void test081()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node0 = new Node(94, (-2749), 68);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node0, node0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeCheck", e);
      }
  }

  @Test(timeout = 4000)
  public void test082()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      DefaultPassConfig defaultPassConfig0 = new DefaultPassConfig(compilerOptions0);
      Stack<JSModule> stack0 = new Stack<JSModule>();
      JSModuleGraph jSModuleGraph0 = new JSModuleGraph(stack0);
      CrossModuleCodeMotion crossModuleCodeMotion0 = new CrossModuleCodeMotion(compiler0, jSModuleGraph0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, crossModuleCodeMotion0, (ScopeCreator) null);
      Node node0 = new Node(95, (-847), (-847));
      TypeCheck typeCheck0 = defaultPassConfig0.makeTypeCheck(compiler0);
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node0, node0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeCheck", e);
      }
  }

  @Test(timeout = 4000)
  public void test083()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      CheckAccidentalSemicolon checkAccidentalSemicolon0 = new CheckAccidentalSemicolon(compilerOptions0.checkUndefinedProperties);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkAccidentalSemicolon0);
      DefaultPassConfig defaultPassConfig0 = new DefaultPassConfig(compilerOptions0);
      TypeCheck typeCheck0 = defaultPassConfig0.makeTypeCheck(compiler0);
      Node node0 = new Node(34, 34, 409);
      Node node1 = new Node(98, node0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(35, Node.PARENTHESIZED_PROP);
  }

  @Test(timeout = 4000)
  public void test084()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node0 = new Node(99, 86, 56);
      Node node1 = new Node(127, node0);
      typeCheck0.processForTesting(node0, node0);
      assertEquals(1, compiler0.getErrorCount());
      assertTrue(compiler0.hasErrors());
  }

  @Test(timeout = 4000)
  public void test085()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
      Node node0 = new Node(101, 101, 104);
      typeCheck0.visit(nodeTraversal0, node0, node0);
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test086()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      ArrayList<JSSourceFile> arrayList0 = new ArrayList<JSSourceFile>();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) arrayList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
      LinkedList<JSType> linkedList1 = new LinkedList<JSType>();
      Node node0 = jSTypeRegistry0.createParameters((List<JSType>) linkedList1);
      Node node1 = new Node(102, node0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(0, node1.getSideEffectFlags());
  }

  @Test(timeout = 4000)
  public void test087()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      CheckAccidentalSemicolon checkAccidentalSemicolon0 = new CheckAccidentalSemicolon(compilerOptions0.checkProvides);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkAccidentalSemicolon0);
      DefaultPassConfig defaultPassConfig0 = new DefaultPassConfig(compilerOptions0);
      TypeCheck typeCheck0 = defaultPassConfig0.makeTypeCheck(compiler0);
      Node node0 = new Node(104, 150, 150);
      typeCheck0.visit(nodeTraversal0, node0, node0);
      assertEquals(1, compiler0.getErrorCount());
      assertTrue(compiler0.hasErrors());
  }

  @Test(timeout = 4000)
  public void test088()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
      Node node0 = new Node(105, 104, 104);
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node0, node0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeCheck", e);
      }
  }

  @Test(timeout = 4000)
  public void test089()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
      Node node0 = Node.newString("");
      Node node1 = new Node(108, node0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(42, Node.SIDE_EFFECT_FLAGS);
  }

  @Test(timeout = 4000)
  public void test090()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
      Node node0 = Node.newString("b<ajh(bYs&YYI\"uf\"");
      Node node1 = new Node(109, node0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(1, compiler0.getErrorCount());
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test091()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      CheckAccidentalSemicolon checkAccidentalSemicolon0 = new CheckAccidentalSemicolon(compilerOptions0.checkProvides);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkAccidentalSemicolon0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, reverseAbstractInterpreter0, jSTypeRegistry0);
      Node node0 = new Node(110, 110, 137);
      typeCheck0.visit(nodeTraversal0, node0, node0);
      assertEquals(1, Node.FLAG_GLOBAL_STATE_UNMODIFIED);
  }

  @Test(timeout = 4000)
  public void test092()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      CheckAccidentalSemicolon checkAccidentalSemicolon0 = new CheckAccidentalSemicolon(compilerOptions0.reportMissingOverride);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkAccidentalSemicolon0);
      DefaultPassConfig defaultPassConfig0 = new DefaultPassConfig(compilerOptions0);
      Node node0 = new Node(111, 111, 72);
      TypeCheck typeCheck0 = defaultPassConfig0.makeTypeCheck(compiler0);
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node0, node0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeCheck", e);
      }
  }

  @Test(timeout = 4000)
  public void test093()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
      Node node0 = new Node(85, 85, 85);
      Node node1 = new Node(112, node0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(39, Node.EMPTY_BLOCK);
  }

  @Test(timeout = 4000)
  public void test094()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      CheckAccidentalSemicolon checkAccidentalSemicolon0 = new CheckAccidentalSemicolon(compilerOptions0.reportMissingOverride);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkAccidentalSemicolon0);
      DefaultPassConfig defaultPassConfig0 = new DefaultPassConfig(compilerOptions0);
      TypeCheck typeCheck0 = defaultPassConfig0.makeTypeCheck(compiler0);
      Node node0 = compiler0.parseInputs();
      Node node1 = new Node(113, node0, node0);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertEquals(31, Node.SKIP_INDEXES_PROP);
  }

  @Test(timeout = 4000)
  public void test095()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      ArrayList<JSSourceFile> arrayList0 = new ArrayList<JSSourceFile>();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) arrayList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
      Node node0 = new Node(114, 114, 114);
      typeCheck0.visit(nodeTraversal0, node0, node0);
      assertEquals(7, Node.LOCAL_PROP);
  }

  @Test(timeout = 4000)
  public void test096()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      CheckAccidentalSemicolon checkAccidentalSemicolon0 = new CheckAccidentalSemicolon(compilerOptions0.checkFunctions);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkAccidentalSemicolon0);
      DefaultPassConfig defaultPassConfig0 = new DefaultPassConfig(compilerOptions0);
      TypeCheck typeCheck0 = defaultPassConfig0.makeTypeCheck(compiler0);
      Node node0 = Node.newString("");
      Node node1 = new Node(115, node0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(22, Node.TARGETBLOCK_PROP);
  }

  @Test(timeout = 4000)
  public void test097()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
      Node node0 = Node.newString("");
      Node node1 = new Node(116, node0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertFalse(node0.hasOneChild());
  }

  @Test(timeout = 4000)
  public void test098()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
      Node node0 = Node.newString("");
      Node node1 = new Node(117, node0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(1, node1.getChildCount());
  }

  @Test(timeout = 4000)
  public void test099()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      CheckAccidentalSemicolon checkAccidentalSemicolon0 = new CheckAccidentalSemicolon(compilerOptions0.checkRequires);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkAccidentalSemicolon0);
      DefaultPassConfig defaultPassConfig0 = new DefaultPassConfig(compilerOptions0);
      TypeCheck typeCheck0 = defaultPassConfig0.makeTypeCheck(compiler0);
      Node node0 = new Node(409, 409, 124);
      Node node1 = new Node(119, node0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(44, Node.IS_OPTIONAL_PARAM);
  }

  @Test(timeout = 4000)
  public void test100()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      PriorityQueue<JSSourceFile> priorityQueue0 = new PriorityQueue<JSSourceFile>();
      ArrayList<JSSourceFile> arrayList0 = new ArrayList<JSSourceFile>(priorityQueue0);
      compiler0.compile((List<JSSourceFile>) arrayList0, (List<JSSourceFile>) arrayList0, compilerOptions0);
      CheckAccidentalSemicolon checkAccidentalSemicolon0 = new CheckAccidentalSemicolon(compilerOptions0.checkMethods);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkAccidentalSemicolon0);
      DefaultPassConfig defaultPassConfig0 = new DefaultPassConfig(compilerOptions0);
      TypeCheck typeCheck0 = defaultPassConfig0.makeTypeCheck(compiler0);
      Node node0 = new Node(120, 120, 72);
      typeCheck0.visit(nodeTraversal0, node0, node0);
      assertEquals(1, Node.LEFT);
  }

  @Test(timeout = 4000)
  public void test101()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
      Node node0 = new Node(121, 1573, 1573);
      typeCheck0.visit(nodeTraversal0, node0, node0);
      assertTrue(compiler0.hasErrors());
      assertEquals(1, compiler0.getErrorCount());
  }

  @Test(timeout = 4000)
  public void test102()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
      Node node0 = new Node(122, 52, 68);
      typeCheck0.visit(nodeTraversal0, node0, node0);
      assertEquals(40, Node.ORIGINALNAME_PROP);
  }

  @Test(timeout = 4000)
  public void test103()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, syntacticScopeCreator0);
      Node node0 = Node.newString("");
      Node node1 = new Node(123, node0);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertEquals(1, compiler0.getErrorCount());
      assertTrue(compiler0.hasErrors());
  }

  @Test(timeout = 4000)
  public void test104()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      Node node0 = new Node(124, (-398), (-398));
      typeCheck0.visit(nodeTraversal0, node0, node0);
      assertEquals(45, Node.IS_VAR_ARGS_PARAM);
  }

  @Test(timeout = 4000)
  public void test105()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
      Node node0 = new Node((-3401), (-3401), (-3401));
      Node node1 = new Node(126, node0);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertEquals(4, Node.FLAG_ARGUMENTS_UNMODIFIED);
  }

  @Test(timeout = 4000)
  public void test106()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      CheckAccidentalSemicolon checkAccidentalSemicolon0 = new CheckAccidentalSemicolon(compilerOptions0.checkRequires);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkAccidentalSemicolon0);
      DefaultPassConfig defaultPassConfig0 = new DefaultPassConfig(compilerOptions0);
      TypeCheck typeCheck0 = defaultPassConfig0.makeTypeCheck(compiler0);
      Node node0 = new Node(34, 34, 409);
      Node node1 = new Node(127, node0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(1, compiler0.getErrorCount());
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test107()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
      Node node0 = new Node(128, 128, 128);
      typeCheck0.visit(nodeTraversal0, node0, node0);
      assertTrue(compiler0.hasErrors());
      assertEquals(1, compiler0.getErrorCount());
  }

  @Test(timeout = 4000)
  public void test108()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
      Node node0 = new Node(129, 129, 129);
      typeCheck0.visit(nodeTraversal0, node0, node0);
      assertEquals(1, compiler0.getErrorCount());
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test109()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
      Node node0 = new Node(130, (-593), (-93));
      typeCheck0.visit(nodeTraversal0, node0, node0);
      assertEquals(32, Node.INCRDECR_PROP);
  }

  @Test(timeout = 4000)
  public void test110()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node0 = new Node(100, 21, 21);
      Node node1 = new Node(131, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(1, compiler0.getErrorCount());
      assertTrue(compiler0.hasErrors());
  }

  @Test(timeout = 4000)
  public void test111()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      CheckAccidentalSemicolon checkAccidentalSemicolon0 = new CheckAccidentalSemicolon(compilerOptions0.checkMethods);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkAccidentalSemicolon0);
      DefaultPassConfig defaultPassConfig0 = new DefaultPassConfig(compilerOptions0);
      TypeCheck typeCheck0 = defaultPassConfig0.makeTypeCheck(compiler0);
      Node node0 = new Node(133, 4420, 170);
      typeCheck0.visit(nodeTraversal0, node0, node0);
      assertTrue(compiler0.hasErrors());
      assertEquals(1, compiler0.getErrorCount());
  }

  @Test(timeout = 4000)
  public void test112()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      ArrayList<JSSourceFile> arrayList0 = new ArrayList<JSSourceFile>();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) arrayList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
      MemoizedScopeCreator memoizedScopeCreator0 = new MemoizedScopeCreator(syntacticScopeCreator0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, memoizedScopeCreator0);
      Node node0 = Node.newString("");
      Node node1 = new Node(134, node0);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertEquals(1, compiler0.getErrorCount());
      assertTrue(compiler0.hasErrors());
  }

  @Test(timeout = 4000)
  public void test113()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      Node node0 = new Node(135, 1431655764, (-938));
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node0, node0);
      assertEquals(1, compiler0.getErrorCount());
      assertTrue(compiler0.hasErrors());
  }

  @Test(timeout = 4000)
  public void test114()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node0 = new Node(136, (-3159), 136);
      // Undeclared exception!
      try { 
        typeCheck0.visit((NodeTraversal) null, node0, node0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeCheck", e);
      }
  }

  @Test(timeout = 4000)
  public void test115()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
      Node node0 = new Node(138, (-3806), 138);
      typeCheck0.visit(nodeTraversal0, node0, node0);
      assertTrue(compiler0.hasErrors());
      assertEquals(1, compiler0.getErrorCount());
  }

  @Test(timeout = 4000)
  public void test116()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
      MemoizedScopeCreator memoizedScopeCreator0 = new MemoizedScopeCreator((ScopeCreator) null);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, memoizedScopeCreator0);
      Node node0 = new Node(139, (-1501), 59);
      typeCheck0.visit(nodeTraversal0, node0, node0);
      assertEquals(1, compiler0.getErrorCount());
      assertTrue(compiler0.hasErrors());
  }

  @Test(timeout = 4000)
  public void test117()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      ArrayList<JSSourceFile> arrayList0 = new ArrayList<JSSourceFile>();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) arrayList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
      Node node0 = new Node(140, 92, 92);
      typeCheck0.visit(nodeTraversal0, node0, node0);
      assertEquals(1, compiler0.getErrorCount());
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test118()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
      Node node0 = Node.newString("");
      Node node1 = new Node(141, node0);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertTrue(compiler0.hasErrors());
      assertEquals(1, compiler0.getErrorCount());
  }

  @Test(timeout = 4000)
  public void test119()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      CheckUnreachableCode checkUnreachableCode0 = new CheckUnreachableCode(compiler0, compilerOptions0.checkMissingGetCssNameLevel);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkUnreachableCode0, (ScopeCreator) null);
      Node node0 = new Node(142, 923, 923);
      typeCheck0.visit(nodeTraversal0, node0, node0);
      assertEquals(1, compiler0.getErrorCount());
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test120()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
      Node node0 = new Node(143, (-2183), 170);
      typeCheck0.visit(nodeTraversal0, node0, node0);
      assertEquals(1, compiler0.getErrorCount());
      assertTrue(compiler0.hasErrors());
  }

  @Test(timeout = 4000)
  public void test121()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      CheckAccidentalSemicolon checkAccidentalSemicolon0 = new CheckAccidentalSemicolon(compilerOptions0.reportMissingOverride);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkAccidentalSemicolon0);
      DefaultPassConfig defaultPassConfig0 = new DefaultPassConfig(compilerOptions0);
      TypeCheck typeCheck0 = defaultPassConfig0.makeTypeCheck(compiler0);
      Node node0 = new Node(144, 68, 144);
      typeCheck0.visit(nodeTraversal0, node0, node0);
      assertEquals(1, compiler0.getErrorCount());
      assertTrue(compiler0.hasErrors());
  }

  @Test(timeout = 4000)
  public void test122()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      MemoizedScopeCreator memoizedScopeCreator0 = new MemoizedScopeCreator((ScopeCreator) null);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, memoizedScopeCreator0);
      Node node0 = new Node(145, 145, 74);
      typeCheck0.visit(nodeTraversal0, node0, node0);
      assertTrue(compiler0.hasErrors());
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test123()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      CheckAccidentalSemicolon checkAccidentalSemicolon0 = new CheckAccidentalSemicolon(compilerOptions0.checkRequires);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkAccidentalSemicolon0);
      DefaultPassConfig defaultPassConfig0 = new DefaultPassConfig(compilerOptions0);
      TypeCheck typeCheck0 = defaultPassConfig0.makeTypeCheck(compiler0);
      Node node0 = new Node(34, 391, 409);
      Node node1 = new Node(146, node0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertTrue(compiler0.hasErrors());
      assertEquals(1, compiler0.getErrorCount());
  }

  @Test(timeout = 4000)
  public void test124()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
      Node node0 = new Node(147, 106, 147);
      typeCheck0.visit(nodeTraversal0, node0, node0);
      assertEquals(2, Node.SPECIALCALL_WITH);
  }

  @Test(timeout = 4000)
  public void test125()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
      Node node0 = new Node(148, 148, 9);
      typeCheck0.visit(nodeTraversal0, node0, node0);
      assertFalse(node0.isQuotedString());
  }

  @Test(timeout = 4000)
  public void test126()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, typedScopeCreator0);
      Node node0 = new Node(149, 1831, 1831);
      typeCheck0.visit(nodeTraversal0, node0, node0);
      assertTrue(compiler0.hasErrors());
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test127()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      ArrayList<JSSourceFile> arrayList0 = new ArrayList<JSSourceFile>();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) arrayList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
      Node node0 = new Node(150, 157, 52);
      typeCheck0.visit(nodeTraversal0, node0, node0);
      assertEquals(1, compiler0.getErrorCount());
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test128()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      CheckAccidentalSemicolon checkAccidentalSemicolon0 = new CheckAccidentalSemicolon(compilerOptions0.brokenClosureRequiresLevel);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkAccidentalSemicolon0);
      DefaultPassConfig defaultPassConfig0 = new DefaultPassConfig(compilerOptions0);
      TypeCheck typeCheck0 = defaultPassConfig0.makeTypeCheck(compiler0);
      Node node0 = new Node(151, (-440), 63743);
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node0, node0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 151
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test129()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node0 = new Node(152, 59, 59);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node0, node0);
      assertEquals(2, Node.SPECIALCALL_WITH);
  }

  @Test(timeout = 4000)
  public void test130()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      DefaultPassConfig defaultPassConfig0 = new DefaultPassConfig(compilerOptions0);
      UnfoldCompoundAssignments unfoldCompoundAssignments0 = new UnfoldCompoundAssignments(compiler0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, unfoldCompoundAssignments0);
      TypeCheck typeCheck0 = defaultPassConfig0.makeTypeCheck(compiler0);
      Node node0 = new Node(2480, 2480, 2480);
      Node node1 = new Node(153, node0);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertEquals(34, Node.NAME_PROP);
  }

  @Test(timeout = 4000)
  public void test131()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Stack<JSSourceFile> stack0 = new Stack<JSSourceFile>();
      compiler0.compile((List<JSSourceFile>) stack0, (List<JSSourceFile>) stack0, compilerOptions0);
      DefaultPassConfig defaultPassConfig0 = new DefaultPassConfig(compilerOptions0);
      Node node0 = new Node(37, 37, 37);
      Node node1 = new Node(32, node0, node0, 33, 32);
      Node node2 = new Node(16, node1, 31, 2);
      TypeCheck typeCheck0 = defaultPassConfig0.makeTypeCheck(compiler0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      typeCheck0.visit(nodeTraversal0, node2, node0);
      assertFalse(node2.isSyntheticBlock());
  }

  @Test(timeout = 4000)
  public void test132()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      CheckAccidentalSemicolon checkAccidentalSemicolon0 = new CheckAccidentalSemicolon(compilerOptions0.reportUnknownTypes);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkAccidentalSemicolon0);
      Node node0 = new Node(0, 43, 0);
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      CheckLevel checkLevel0 = CheckLevel.ERROR;
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0, compilerOptions0.checkGlobalThisLevel, checkLevel0);
      typeCheck0.visit(nodeTraversal0, node0, (Node) null);
      assertEquals(2, compiler0.getErrorCount());
  }

  @Test(timeout = 4000)
  public void test133()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
      Node node0 = new Node(105, 104, 104);
      boolean boolean0 = typeCheck0.visitName(nodeTraversal0, node0, node0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void test134()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      PriorityQueue<JSSourceFile> priorityQueue0 = new PriorityQueue<JSSourceFile>();
      ArrayList<JSSourceFile> arrayList0 = new ArrayList<JSSourceFile>(priorityQueue0);
      compiler0.compile((List<JSSourceFile>) arrayList0, (List<JSSourceFile>) arrayList0, compilerOptions0);
      CheckAccidentalSemicolon checkAccidentalSemicolon0 = new CheckAccidentalSemicolon(compilerOptions0.checkMethods);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkAccidentalSemicolon0);
      DefaultPassConfig defaultPassConfig0 = new DefaultPassConfig(compilerOptions0);
      TypeCheck typeCheck0 = defaultPassConfig0.makeTypeCheck(compiler0);
      Node node0 = new Node(120, 120, 72);
      boolean boolean0 = typeCheck0.visitName(nodeTraversal0, node0, node0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void test135()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      LinkedList<JSType> linkedList1 = new LinkedList<JSType>();
      Node node0 = jSTypeRegistry0.createParameters((List<JSType>) linkedList1);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      boolean boolean0 = typeCheck0.visitName(nodeTraversal0, node0, node0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void test136()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      CheckAccidentalSemicolon checkAccidentalSemicolon0 = new CheckAccidentalSemicolon(compilerOptions0.checkMethods);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkAccidentalSemicolon0);
      DefaultPassConfig defaultPassConfig0 = new DefaultPassConfig(compilerOptions0);
      TypeCheck typeCheck0 = defaultPassConfig0.makeTypeCheck(compiler0);
      Node node0 = new Node(118, 118, 70);
      boolean boolean0 = typeCheck0.visitName(nodeTraversal0, node0, node0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void test137()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
      Node node0 = Node.newString("");
      Node node1 = new Node(118, node0);
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node1, node0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeCheck", e);
      }
  }

  @Test(timeout = 4000)
  public void test138()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node0 = new Node(137, 2, 137);
      node0.addSuppression((String) null);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node0, node0);
      assertEquals(1, compiler0.getErrorCount());
      assertTrue(compiler0.hasErrors());
  }

  @Test(timeout = 4000)
  public void test139()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      CheckAccidentalSemicolon checkAccidentalSemicolon0 = new CheckAccidentalSemicolon(compilerOptions0.checkMissingReturn);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkAccidentalSemicolon0);
      DefaultPassConfig defaultPassConfig0 = new DefaultPassConfig(compilerOptions0);
      TypeCheck typeCheck0 = defaultPassConfig0.makeTypeCheck(compiler0);
      Node node0 = new Node(34, 34, 409);
      typeCheck0.visit(nodeTraversal0, node0, node0);
      double double0 = typeCheck0.getTypedPercent();
      assertEquals(1, compiler0.getErrorCount());
      assertEquals(0.0, double0, 0.01);
  }

  @Test(timeout = 4000)
  public void test140()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile((List<JSSourceFile>) linkedList0, (List<JSSourceFile>) linkedList0, compilerOptions0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      double double0 = typeCheck0.getTypedPercent();
      assertEquals(0.0, double0, 0.01);
  }
}
