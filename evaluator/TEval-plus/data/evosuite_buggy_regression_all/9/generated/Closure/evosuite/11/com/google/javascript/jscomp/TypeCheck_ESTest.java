/*
 * This file was automatically generated by EvoSuite
 * Wed Jul 12 04:42:12 GMT 2023
 */

package com.google.javascript.jscomp;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import com.google.javascript.jscomp.AbstractCompiler;
import com.google.javascript.jscomp.CleanupPasses;
import com.google.javascript.jscomp.ClosureCodingConvention;
import com.google.javascript.jscomp.CoalesceVariableNames;
import com.google.javascript.jscomp.Compiler;
import com.google.javascript.jscomp.CompilerOptions;
import com.google.javascript.jscomp.Denormalize;
import com.google.javascript.jscomp.FunctionNames;
import com.google.javascript.jscomp.GroupVariableDeclarations;
import com.google.javascript.jscomp.NodeTraversal;
import com.google.javascript.jscomp.RecordFunctionInformation;
import com.google.javascript.jscomp.Scope;
import com.google.javascript.jscomp.ScopeCreator;
import com.google.javascript.jscomp.SourceFile;
import com.google.javascript.jscomp.TypeCheck;
import com.google.javascript.jscomp.type.SemanticReverseAbstractInterpreter;
import com.google.javascript.rhino.ErrorReporter;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.jstype.JSTypeRegistry;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class TypeCheck_ESTest extends TypeCheck_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void test00()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ArrayList<SourceFile> arrayList0 = new ArrayList<SourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.init((List<SourceFile>) arrayList0, (List<SourceFile>) arrayList0, compilerOptions0);
      Node node0 = Node.newString(5204, "}oJTZ{Y0Z6");
      CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
      TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
      Node node1 = new Node(37, node0, 39, 31);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
      typeCheck0.visit(nodeTraversal0, node1, node1);
  }

  @Test(timeout = 4000)
  public void test01()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
      ArrayList<SourceFile> arrayList0 = new ArrayList<SourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.init((List<SourceFile>) arrayList0, (List<SourceFile>) arrayList0, compilerOptions0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      Node node0 = Node.newNumber(0.0, 1349, 131);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node0, node0);
      assertFalse(node0.isCall());
  }

  @Test(timeout = 4000)
  public void test02()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ArrayList<SourceFile> arrayList0 = new ArrayList<SourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.init((List<SourceFile>) arrayList0, (List<SourceFile>) arrayList0, compilerOptions0);
      Node node0 = Node.newString(5204, "}oJTZ{Y0Z6");
      CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
      TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
      Node node1 = new Node(37, node0, 39, 31);
      // Undeclared exception!
      try { 
        typeCheck0.processForTesting(node0, node0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 5204
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test03()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
      ArrayList<SourceFile> arrayList0 = new ArrayList<SourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.init((List<SourceFile>) arrayList0, (List<SourceFile>) arrayList0, compilerOptions0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node0 = compiler0.parseSyntheticCode("First argument must be 'this'.", "First argument must be 'this'.");
      // Undeclared exception!
      try { 
        typeCheck0.processForTesting(node0, node0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.common.base.Preconditions", e);
      }
  }

  @Test(timeout = 4000)
  public void test04()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      ArrayList<SourceFile> arrayList0 = new ArrayList<SourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.init((List<SourceFile>) arrayList0, (List<SourceFile>) arrayList0, compilerOptions0);
      FunctionNames functionNames0 = new FunctionNames(compiler0);
      RecordFunctionInformation recordFunctionInformation0 = new RecordFunctionInformation(compiler0, functionNames0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, recordFunctionInformation0);
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node0 = new Node(118);
      typeCheck0.visit(nodeTraversal0, node0, node0);
      assertEquals(53, Node.INPUT_ID);
  }

  @Test(timeout = 4000)
  public void test05()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
      ArrayList<SourceFile> arrayList0 = new ArrayList<SourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.init((List<SourceFile>) arrayList0, (List<SourceFile>) arrayList0, compilerOptions0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      Node node0 = compiler0.parseSyntheticCode("// Input %num%", "// Input %num%");
      boolean boolean0 = typeCheck0.shouldTraverse(nodeTraversal0, node0, node0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void test06()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
      ArrayList<SourceFile> arrayList0 = new ArrayList<SourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.init((List<SourceFile>) arrayList0, (List<SourceFile>) arrayList0, compilerOptions0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      Node node0 = new Node(149);
      typeCheck0.visit(nodeTraversal0, node0, node0);
      assertEquals(1, compiler0.getErrorCount());
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test07()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
      LinkedList<SourceFile> linkedList0 = new LinkedList<SourceFile>();
      CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
      compiler0.init((List<SourceFile>) linkedList0, (List<SourceFile>) linkedList0, compilerOptions0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, (NodeTraversal.Callback) null);
      Node node0 = Node.newString(4, "<<TUmII4k#*F<");
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node0, node0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeCheck", e);
      }
  }

  @Test(timeout = 4000)
  public void test08()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
      ArrayList<SourceFile> arrayList0 = new ArrayList<SourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.init((List<SourceFile>) arrayList0, (List<SourceFile>) arrayList0, compilerOptions0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      Node node0 = new Node(5);
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node0, node0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 5
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test09()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
      ArrayList<SourceFile> arrayList0 = new ArrayList<SourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.init((List<SourceFile>) arrayList0, (List<SourceFile>) arrayList0, compilerOptions0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      Node node0 = Node.newString(9, "");
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node0, node0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeCheck", e);
      }
  }

  @Test(timeout = 4000)
  public void test10()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
      ArrayList<SourceFile> arrayList0 = new ArrayList<SourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.init((List<SourceFile>) arrayList0, (List<SourceFile>) arrayList0, compilerOptions0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      Node node0 = new Node(10);
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node0, node0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeCheck", e);
      }
  }

  @Test(timeout = 4000)
  public void test11()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ArrayList<SourceFile> arrayList0 = new ArrayList<SourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.init((List<SourceFile>) arrayList0, (List<SourceFile>) arrayList0, compilerOptions0);
      Node node0 = Node.newString(143, "wNkp`F[}YE`\"");
      CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
      TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
      Node node1 = new Node(15, node0, (-1411), (-596));
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertTrue(node1.hasOneChild());
  }

  @Test(timeout = 4000)
  public void test12()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ArrayList<SourceFile> arrayList0 = new ArrayList<SourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.init((List<SourceFile>) arrayList0, (List<SourceFile>) arrayList0, compilerOptions0);
      FunctionNames functionNames0 = new FunctionNames(compiler0);
      RecordFunctionInformation recordFunctionInformation0 = new RecordFunctionInformation(compiler0, functionNames0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, recordFunctionInformation0);
      Node node0 = Node.newString(117, "");
      CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
      TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
      Node node1 = Node.newString(16, "u/ kV");
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node1, node0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeCheck", e);
      }
  }

  @Test(timeout = 4000)
  public void test13()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
      ArrayList<SourceFile> arrayList0 = new ArrayList<SourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.init((List<SourceFile>) arrayList0, (List<SourceFile>) arrayList0, compilerOptions0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      Node node0 = Node.newString(17, "INHERIT_DOC");
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node0, node0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeCheck", e);
      }
  }

  @Test(timeout = 4000)
  public void test14()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
      ArrayList<SourceFile> arrayList0 = new ArrayList<SourceFile>();
      CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
      compiler0.init((List<SourceFile>) arrayList0, (List<SourceFile>) arrayList0, compilerOptions0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      Node node0 = Node.newString(18, "");
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node0, node0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeCheck", e);
      }
  }

  @Test(timeout = 4000)
  public void test15()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      ArrayList<SourceFile> arrayList0 = new ArrayList<SourceFile>();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.init((List<SourceFile>) arrayList0, (List<SourceFile>) arrayList0, compilerOptions0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      Node node0 = Node.newString(19, "iAQ}dMttY=aJpx2");
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node0, (Node) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeCheck", e);
      }
  }

  @Test(timeout = 4000)
  public void test16()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
      LinkedList<SourceFile> linkedList0 = new LinkedList<SourceFile>();
      CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
      compiler0.init((List<SourceFile>) linkedList0, (List<SourceFile>) linkedList0, compilerOptions0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      Node node0 = Node.newString(27, "unknown");
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node0, node0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeCheck", e);
      }
  }

  @Test(timeout = 4000)
  public void test17()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ArrayList<SourceFile> arrayList0 = new ArrayList<SourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.init((List<SourceFile>) arrayList0, (List<SourceFile>) arrayList0, compilerOptions0);
      FunctionNames functionNames0 = new FunctionNames(compiler0);
      RecordFunctionInformation recordFunctionInformation0 = new RecordFunctionInformation(compiler0, functionNames0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, recordFunctionInformation0);
      Node node0 = Node.newString(103, "");
      CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
      TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
      Node node1 = new Node(30, node0, 138, 149);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      double double0 = typeCheck0.getTypedPercent();
      assertEquals(0.0, double0, 0.01);
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test18()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
      LinkedList<SourceFile> linkedList0 = new LinkedList<SourceFile>();
      CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
      compiler0.init((List<SourceFile>) linkedList0, (List<SourceFile>) linkedList0, compilerOptions0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, (NodeTraversal.Callback) null);
      Node node0 = new Node(33);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0, compilerOptions0.checkMissingGetCssNameLevel, compilerOptions0.checkMissingGetCssNameLevel);
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node0, node0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeCheck", e);
      }
  }

  @Test(timeout = 4000)
  public void test19()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ArrayList<SourceFile> arrayList0 = new ArrayList<SourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.init((List<SourceFile>) arrayList0, (List<SourceFile>) arrayList0, compilerOptions0);
      Denormalize.StripConstantAnnotations denormalize_StripConstantAnnotations0 = new Denormalize.StripConstantAnnotations(compiler0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, denormalize_StripConstantAnnotations0);
      Node node0 = Node.newString((-2078), "od4V0cJ<MdF?J(");
      CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
      TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
      Node node1 = new Node(42, node0, (-191), (-1603));
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node1, node1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeCheck", e);
      }
  }

  @Test(timeout = 4000)
  public void test20()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ArrayList<SourceFile> arrayList0 = new ArrayList<SourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.init((List<SourceFile>) arrayList0, (List<SourceFile>) arrayList0, compilerOptions0);
      Denormalize.StripConstantAnnotations denormalize_StripConstantAnnotations0 = new Denormalize.StripConstantAnnotations(compiler0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, denormalize_StripConstantAnnotations0);
      Node node0 = Node.newString((-2078), "od4V0cJ<MdF?J(");
      CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
      TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
      Node node1 = new Node(43, node0, (-191), (-1603));
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertEquals(29, Node.JSDOC_INFO_PROP);
  }

  @Test(timeout = 4000)
  public void test21()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ArrayList<SourceFile> arrayList0 = new ArrayList<SourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.init((List<SourceFile>) arrayList0, (List<SourceFile>) arrayList0, compilerOptions0);
      Node node0 = Node.newString(143, "wNkp`F[}YE`\"");
      CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
      TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
      Node node1 = new Node(51, node0, 9, 29);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(0, compiler0.getErrorCount());
      assertFalse(compiler0.hasErrors());
  }

  @Test(timeout = 4000)
  public void test22()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
      ArrayList<SourceFile> arrayList0 = new ArrayList<SourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.init((List<SourceFile>) arrayList0, (List<SourceFile>) arrayList0, compilerOptions0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal((AbstractCompiler) null, typeCheck0);
      Node node0 = new Node(63);
      typeCheck0.visit(nodeTraversal0, node0, node0);
      typeCheck0.visit(nodeTraversal0, node0, node0);
      assertFalse(node0.isSwitch());
  }

  @Test(timeout = 4000)
  public void test23()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
      ArrayList<SourceFile> arrayList0 = new ArrayList<SourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.init((List<SourceFile>) arrayList0, (List<SourceFile>) arrayList0, compilerOptions0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node[] nodeArray0 = new Node[0];
      Node node0 = new Node(83, nodeArray0, 65500, 83);
      typeCheck0.visit((NodeTraversal) null, node0, node0);
      assertEquals(42, Node.SIDE_EFFECT_FLAGS);
  }

  @Test(timeout = 4000)
  public void test24()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
      ArrayList<SourceFile> arrayList0 = new ArrayList<SourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.init((List<SourceFile>) arrayList0, (List<SourceFile>) arrayList0, compilerOptions0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      Node node0 = new Node(88);
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node0, node0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeCheck", e);
      }
  }

  @Test(timeout = 4000)
  public void test25()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
      ArrayList<SourceFile> arrayList0 = new ArrayList<SourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.init((List<SourceFile>) arrayList0, (List<SourceFile>) arrayList0, compilerOptions0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      Node node0 = Node.newString(91, "property {0} not defined on any superclass of {1}");
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node0, node0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeCheck", e);
      }
  }

  @Test(timeout = 4000)
  public void test26()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ArrayList<SourceFile> arrayList0 = new ArrayList<SourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.init((List<SourceFile>) arrayList0, (List<SourceFile>) arrayList0, compilerOptions0);
      FunctionNames functionNames0 = new FunctionNames(compiler0);
      RecordFunctionInformation recordFunctionInformation0 = new RecordFunctionInformation(compiler0, functionNames0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, recordFunctionInformation0);
      Node node0 = Node.newString(103, "-iF<{RL[Aod)");
      CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
      TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node0, node0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeCheck", e);
      }
  }

  @Test(timeout = 4000)
  public void test27()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ArrayList<SourceFile> arrayList0 = new ArrayList<SourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      CoalesceVariableNames coalesceVariableNames0 = new CoalesceVariableNames(compiler0, true);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, coalesceVariableNames0, (ScopeCreator) null);
      compiler0.init((List<SourceFile>) arrayList0, (List<SourceFile>) arrayList0, compilerOptions0);
      Node node0 = Node.newString(116, ")BDxUG1_e+x#TAv]");
      CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
      TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
      Node node1 = new Node(107, node0, (-4067), 4095);
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node1, node0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 107
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test28()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
      ArrayList<SourceFile> arrayList0 = new ArrayList<SourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.init((List<SourceFile>) arrayList0, (List<SourceFile>) arrayList0, compilerOptions0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      Node node0 = Node.newString(113, "jfTPi 5");
      typeCheck0.visit(nodeTraversal0, node0, node0);
      assertFalse(node0.isComma());
  }

  @Test(timeout = 4000)
  public void test29()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      ArrayList<SourceFile> arrayList0 = new ArrayList<SourceFile>();
      compiler0.init((List<SourceFile>) arrayList0, (List<SourceFile>) arrayList0, compilerOptions0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      Node node0 = Node.newString(115, ";");
      typeCheck0.visit(nodeTraversal0, node0, node0);
      assertFalse(node0.isSetterDef());
  }

  @Test(timeout = 4000)
  public void test30()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ArrayList<SourceFile> arrayList0 = new ArrayList<SourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.init((List<SourceFile>) arrayList0, (List<SourceFile>) arrayList0, compilerOptions0);
      FunctionNames functionNames0 = new FunctionNames(compiler0);
      RecordFunctionInformation recordFunctionInformation0 = new RecordFunctionInformation(compiler0, functionNames0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, recordFunctionInformation0);
      Node node0 = Node.newString(117, "");
      CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
      TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
      typeCheck0.visit(nodeTraversal0, node0, node0);
      assertEquals(48, Node.DIRECTIVES);
  }

  @Test(timeout = 4000)
  public void test31()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ArrayList<SourceFile> arrayList0 = new ArrayList<SourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.init((List<SourceFile>) arrayList0, (List<SourceFile>) arrayList0, compilerOptions0);
      FunctionNames functionNames0 = new FunctionNames(compiler0);
      RecordFunctionInformation recordFunctionInformation0 = new RecordFunctionInformation(compiler0, functionNames0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, recordFunctionInformation0);
      Node node0 = Node.newString(120, "");
      CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
      TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
      typeCheck0.visit(nodeTraversal0, node0, node0);
      assertEquals(1, Node.FLAG_GLOBAL_STATE_UNMODIFIED);
  }

  @Test(timeout = 4000)
  public void test32()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
      ArrayList<SourceFile> arrayList0 = new ArrayList<SourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.init((List<SourceFile>) arrayList0, (List<SourceFile>) arrayList0, compilerOptions0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      Node node0 = Node.newString(127, "J R");
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node0, node0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 127
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test33()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ArrayList<SourceFile> arrayList0 = new ArrayList<SourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.init((List<SourceFile>) arrayList0, (List<SourceFile>) arrayList0, compilerOptions0);
      Node node0 = Node.newString(143, "wNkp`F[}YE`\"");
      CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
      TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
      Node node1 = new Node(131, node0, node0, node0, node0);
      // Undeclared exception!
      try { 
        typeCheck0.visit((NodeTraversal) null, node1, (Node) null);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 131
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test34()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
      ArrayList<SourceFile> arrayList0 = new ArrayList<SourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.init((List<SourceFile>) arrayList0, (List<SourceFile>) arrayList0, compilerOptions0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      Node node0 = compiler0.parseSyntheticCode("// Input %num%", "// Input %num%");
      typeCheck0.visit(nodeTraversal0, node0, node0);
      assertEquals(37, Node.OPT_ARG_NAME);
  }

  @Test(timeout = 4000)
  public void test35()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, (NodeTraversal.Callback) null);
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
      ArrayList<SourceFile> arrayList0 = new ArrayList<SourceFile>();
      CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
      compiler0.init((List<SourceFile>) arrayList0, (List<SourceFile>) arrayList0, compilerOptions0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node0 = Node.newString(134, "");
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node0, node0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 134
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test36()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
      ArrayList<SourceFile> arrayList0 = new ArrayList<SourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.init((List<SourceFile>) arrayList0, (List<SourceFile>) arrayList0, compilerOptions0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      Node node0 = new Node(137);
      GroupVariableDeclarations groupVariableDeclarations0 = new GroupVariableDeclarations(compiler0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, groupVariableDeclarations0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0, (Scope) null, (ScopeCreator) null, compilerOptions0.reportMissingOverride, compilerOptions0.checkUnreachableCode);
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node0, node0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 137
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test37()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
      ArrayList<SourceFile> arrayList0 = new ArrayList<SourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.init((List<SourceFile>) arrayList0, (List<SourceFile>) arrayList0, compilerOptions0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      Node node0 = Node.newString(140, "// Input %num%");
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node0, node0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 140
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test38()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ArrayList<SourceFile> arrayList0 = new ArrayList<SourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.init((List<SourceFile>) arrayList0, (List<SourceFile>) arrayList0, compilerOptions0);
      Node node0 = Node.newString(143, "wNkp`F[}YE`\"");
      CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
      TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node0, node0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 143
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test39()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
      LinkedList<SourceFile> linkedList0 = new LinkedList<SourceFile>();
      CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
      compiler0.init((List<SourceFile>) linkedList0, (List<SourceFile>) linkedList0, compilerOptions0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      Node node0 = new Node(144);
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node0, node0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 144
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test40()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
      ArrayList<SourceFile> arrayList0 = new ArrayList<SourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.init((List<SourceFile>) arrayList0, (List<SourceFile>) arrayList0, compilerOptions0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      Node node0 = Node.newNumber(0.0, 1349, 131);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      Node node1 = new Node(146, node0, 44, 40);
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node1, node1);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 146
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test41()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ArrayList<SourceFile> arrayList0 = new ArrayList<SourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.init((List<SourceFile>) arrayList0, (List<SourceFile>) arrayList0, compilerOptions0);
      Denormalize.StripConstantAnnotations denormalize_StripConstantAnnotations0 = new Denormalize.StripConstantAnnotations(compiler0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, denormalize_StripConstantAnnotations0);
      Node node0 = Node.newString(147, "// Input %num%");
      CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
      TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
      typeCheck0.visit(nodeTraversal0, node0, node0);
      assertFalse(node0.isDebugger());
  }

  @Test(timeout = 4000)
  public void test42()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ArrayList<SourceFile> arrayList0 = new ArrayList<SourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.init((List<SourceFile>) arrayList0, (List<SourceFile>) arrayList0, compilerOptions0);
      FunctionNames functionNames0 = new FunctionNames(compiler0);
      RecordFunctionInformation recordFunctionInformation0 = new RecordFunctionInformation(compiler0, functionNames0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, recordFunctionInformation0);
      Node node0 = Node.newString(120, "");
      CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
      TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
      boolean boolean0 = typeCheck0.visitName(nodeTraversal0, node0, node0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void test43()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
      ArrayList<SourceFile> arrayList0 = new ArrayList<SourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.init((List<SourceFile>) arrayList0, (List<SourceFile>) arrayList0, compilerOptions0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node[] nodeArray0 = new Node[0];
      Node node0 = new Node(83, nodeArray0, 65500, 83);
      boolean boolean0 = typeCheck0.visitName((NodeTraversal) null, node0, node0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void test44()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
      ArrayList<SourceFile> arrayList0 = new ArrayList<SourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.init((List<SourceFile>) arrayList0, (List<SourceFile>) arrayList0, compilerOptions0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      Node node0 = new Node(88);
      // Undeclared exception!
      try { 
        typeCheck0.visitName(nodeTraversal0, node0, node0);
        fail("Expecting exception: UnsupportedOperationException");
      
      } catch(UnsupportedOperationException e) {
         //
         // ASSIGN_BITXOR is not a string node
         //
         verifyException("com.google.javascript.rhino.Node", e);
      }
  }

  @Test(timeout = 4000)
  public void test45()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
      ArrayList<SourceFile> arrayList0 = new ArrayList<SourceFile>();
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.init((List<SourceFile>) arrayList0, (List<SourceFile>) arrayList0, compilerOptions0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      double double0 = typeCheck0.getTypedPercent();
      assertEquals(0.0, double0, 0.01);
  }
}
